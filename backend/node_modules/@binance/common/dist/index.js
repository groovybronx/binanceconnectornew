"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ALGO_REST_API_PROD_URL: () => ALGO_REST_API_PROD_URL,
  ALGO_REST_API_TESTNET_URL: () => ALGO_REST_API_TESTNET_URL,
  AUTO_INVEST_REST_API_PROD_URL: () => AUTO_INVEST_REST_API_PROD_URL,
  AUTO_INVEST_REST_API_TESTNET_URL: () => AUTO_INVEST_REST_API_TESTNET_URL,
  BadRequestError: () => BadRequestError,
  C2C_REST_API_PROD_URL: () => C2C_REST_API_PROD_URL,
  C2C_REST_API_TESTNET_URL: () => C2C_REST_API_TESTNET_URL,
  CONVERT_REST_API_PROD_URL: () => CONVERT_REST_API_PROD_URL,
  CONVERT_REST_API_TESTNET_URL: () => CONVERT_REST_API_TESTNET_URL,
  COPY_TRADING_REST_API_PROD_URL: () => COPY_TRADING_REST_API_PROD_URL,
  COPY_TRADING_REST_API_TESTNET_URL: () => COPY_TRADING_REST_API_TESTNET_URL,
  CRYPTO_LOAN_REST_API_PROD_URL: () => CRYPTO_LOAN_REST_API_PROD_URL,
  CRYPTO_LOAN_REST_API_TESTNET_URL: () => CRYPTO_LOAN_REST_API_TESTNET_URL,
  ConfigurationRestAPI: () => ConfigurationRestAPI,
  ConfigurationWebsocketAPI: () => ConfigurationWebsocketAPI,
  ConfigurationWebsocketStreams: () => ConfigurationWebsocketStreams,
  ConnectorClientError: () => ConnectorClientError,
  DERIVATIVES_TRADING_COIN_FUTURES_REST_API_PROD_URL: () => DERIVATIVES_TRADING_COIN_FUTURES_REST_API_PROD_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_REST_API_TESTNET_URL: () => DERIVATIVES_TRADING_COIN_FUTURES_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_API_PROD_URL: () => DERIVATIVES_TRADING_COIN_FUTURES_WS_API_PROD_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_API_TESTNET_URL: () => DERIVATIVES_TRADING_COIN_FUTURES_WS_API_TESTNET_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_PROD_URL: () => DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_PROD_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_TESTNET_URL: () => DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_TESTNET_URL,
  DERIVATIVES_TRADING_OPTIONS_REST_API_PROD_URL: () => DERIVATIVES_TRADING_OPTIONS_REST_API_PROD_URL,
  DERIVATIVES_TRADING_OPTIONS_WS_STREAMS_PROD_URL: () => DERIVATIVES_TRADING_OPTIONS_WS_STREAMS_PROD_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_PROD_URL: () => DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_PROD_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_TESTNET_URL: () => DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_PROD_URL: () => DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_PROD_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_TESTNET_URL: () => DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL: () => DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_REST_API_TESTNET_URL: () => DERIVATIVES_TRADING_USDS_FUTURES_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_API_PROD_URL: () => DERIVATIVES_TRADING_USDS_FUTURES_WS_API_PROD_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_API_TESTNET_URL: () => DERIVATIVES_TRADING_USDS_FUTURES_WS_API_TESTNET_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_PROD_URL: () => DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_PROD_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_TESTNET_URL: () => DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_TESTNET_URL,
  DUAL_INVESTMENT_REST_API_PROD_URL: () => DUAL_INVESTMENT_REST_API_PROD_URL,
  DUAL_INVESTMENT_REST_API_TESTNET_URL: () => DUAL_INVESTMENT_REST_API_TESTNET_URL,
  FIAT_REST_API_PROD_URL: () => FIAT_REST_API_PROD_URL,
  FIAT_REST_API_TESTNET_URL: () => FIAT_REST_API_TESTNET_URL,
  ForbiddenError: () => ForbiddenError,
  GIFT_CARD_REST_API_PROD_URL: () => GIFT_CARD_REST_API_PROD_URL,
  GIFT_CARD_REST_API_TESTNET_URL: () => GIFT_CARD_REST_API_TESTNET_URL,
  LogLevel: () => LogLevel,
  Logger: () => Logger,
  MARGIN_TRADING_REST_API_PROD_URL: () => MARGIN_TRADING_REST_API_PROD_URL,
  MARGIN_TRADING_REST_API_TESTNET_URL: () => MARGIN_TRADING_REST_API_TESTNET_URL,
  MINING_REST_API_PROD_URL: () => MINING_REST_API_PROD_URL,
  MINING_REST_API_TESTNET_URL: () => MINING_REST_API_TESTNET_URL,
  NFT_REST_API_PROD_URL: () => NFT_REST_API_PROD_URL,
  NFT_REST_API_TESTNET_URL: () => NFT_REST_API_TESTNET_URL,
  NetworkError: () => NetworkError,
  NotFoundError: () => NotFoundError,
  PAY_REST_API_PROD_URL: () => PAY_REST_API_PROD_URL,
  PAY_REST_API_TESTNET_URL: () => PAY_REST_API_TESTNET_URL,
  REBATE_REST_API_PROD_URL: () => REBATE_REST_API_PROD_URL,
  REBATE_REST_API_TESTNET_URL: () => REBATE_REST_API_TESTNET_URL,
  RateLimitBanError: () => RateLimitBanError,
  RequiredError: () => RequiredError,
  SIMPLE_EARN_REST_API_PROD_URL: () => SIMPLE_EARN_REST_API_PROD_URL,
  SIMPLE_EARN_REST_API_TESTNET_URL: () => SIMPLE_EARN_REST_API_TESTNET_URL,
  SPOT_REST_API_MARKET_URL: () => SPOT_REST_API_MARKET_URL,
  SPOT_REST_API_PROD_URL: () => SPOT_REST_API_PROD_URL,
  SPOT_REST_API_TESTNET_URL: () => SPOT_REST_API_TESTNET_URL,
  SPOT_WS_API_PROD_URL: () => SPOT_WS_API_PROD_URL,
  SPOT_WS_API_TESTNET_URL: () => SPOT_WS_API_TESTNET_URL,
  SPOT_WS_STREAMS_MARKET_URL: () => SPOT_WS_STREAMS_MARKET_URL,
  SPOT_WS_STREAMS_PROD_URL: () => SPOT_WS_STREAMS_PROD_URL,
  SPOT_WS_STREAMS_TESTNET_URL: () => SPOT_WS_STREAMS_TESTNET_URL,
  STAKING_REST_API_PROD_URL: () => STAKING_REST_API_PROD_URL,
  STAKING_REST_API_TESTNET_URL: () => STAKING_REST_API_TESTNET_URL,
  SUB_ACCOUNT_REST_API_PROD_URL: () => SUB_ACCOUNT_REST_API_PROD_URL,
  SUB_ACCOUNT_REST_API_TESTNET_URL: () => SUB_ACCOUNT_REST_API_TESTNET_URL,
  ServerError: () => ServerError,
  TimeUnit: () => TimeUnit,
  TooManyRequestsError: () => TooManyRequestsError,
  UnauthorizedError: () => UnauthorizedError,
  VIP_LOAN_REST_API_PROD_URL: () => VIP_LOAN_REST_API_PROD_URL,
  VIP_LOAN_REST_API_TESTNET_URL: () => VIP_LOAN_REST_API_TESTNET_URL,
  WALLET_REST_API_PROD_URL: () => WALLET_REST_API_PROD_URL,
  WALLET_REST_API_TESTNET_URL: () => WALLET_REST_API_TESTNET_URL,
  WebsocketAPIBase: () => WebsocketAPIBase,
  WebsocketCommon: () => WebsocketCommon,
  WebsocketEventEmitter: () => WebsocketEventEmitter,
  WebsocketStreamsBase: () => WebsocketStreamsBase2,
  assertParamExists: () => assertParamExists,
  buildQueryString: () => buildQueryString,
  createStreamHandler: () => createStreamHandler,
  delay: () => delay,
  getSignature: () => getSignature,
  getTimestamp: () => getTimestamp,
  httpRequestFunction: () => httpRequestFunction,
  parseRateLimitHeaders: () => parseRateLimitHeaders,
  randomString: () => randomString,
  removeEmptyValue: () => removeEmptyValue,
  replaceWebsocketStreamsPlaceholders: () => replaceWebsocketStreamsPlaceholders,
  sendRequest: () => sendRequest,
  setSearchParams: () => setSearchParams,
  shouldRetryRequest: () => shouldRetryRequest,
  sortObject: () => sortObject,
  toPathString: () => toPathString,
  validateTimeUnit: () => validateTimeUnit
});
module.exports = __toCommonJS(src_exports);

// src/configuration.ts
var ConfigurationRestAPI = class {
  constructor(param = { apiKey: "" }) {
    this.apiKey = param.apiKey;
    this.apiSecret = param.apiSecret;
    this.basePath = param.basePath;
    this.keepAlive = param.keepAlive ?? true;
    this.compression = param.compression ?? true;
    this.retries = param.retries ?? 3;
    this.backoff = param.backoff ?? 1e3;
    this.privateKey = param.privateKey;
    this.privateKeyPassphrase = param.privateKeyPassphrase;
    this.timeUnit = param.timeUnit;
    this.baseOptions = {
      timeout: this.timeout ?? 1e3,
      proxy: this.proxy && {
        host: this.proxy.host,
        port: this.proxy.port,
        auth: this.proxy.auth
      },
      httpsAgent: this.httpsAgent ?? false,
      headers: {
        "Content-Type": "application/json",
        "X-MBX-APIKEY": this.apiKey
      }
    };
  }
};
var ConfigurationWebsocketAPI = class {
  constructor(param = { apiKey: "" }) {
    this.apiKey = param.apiKey;
    this.apiSecret = param.apiSecret;
    this.wsURL = param.wsURL;
    this.timeout = param.timeout ?? 5e3;
    this.reconnectDelay = param.reconnectDelay ?? 5e3;
    this.compression = param.compression ?? true;
    this.agent = param.agent ?? false;
    this.mode = param.mode ?? "single";
    this.poolSize = param.poolSize ?? 1;
    this.privateKey = param.privateKey;
    this.privateKeyPassphrase = param.privateKeyPassphrase;
    this.timeUnit = param.timeUnit;
  }
};
var ConfigurationWebsocketStreams = class {
  constructor(param = {}) {
    this.wsURL = param.wsURL;
    this.reconnectDelay = param.reconnectDelay ?? 5e3;
    this.compression = param.compression ?? true;
    this.agent = param.agent ?? false;
    this.mode = param.mode ?? "single";
    this.poolSize = param.poolSize ?? 1;
    this.timeUnit = param.timeUnit;
  }
};

// src/constants.ts
var TimeUnit = {
  MILLISECOND: "MILLISECOND",
  millisecond: "millisecond",
  MICROSECOND: "MICROSECOND",
  microsecond: "microsecond"
};
var SPOT_REST_API_PROD_URL = "https://api.binance.com";
var SPOT_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var SPOT_WS_API_PROD_URL = "wss://ws-api.binance.com:443/ws-api/v3";
var SPOT_WS_API_TESTNET_URL = "wss://ws-api.testnet.binance.vision/ws-api/v3";
var SPOT_WS_STREAMS_PROD_URL = "wss://stream.binance.com:9443";
var SPOT_WS_STREAMS_TESTNET_URL = "wss://stream.testnet.binance.vision";
var SPOT_REST_API_MARKET_URL = "https://data-api.binance.vision";
var SPOT_WS_STREAMS_MARKET_URL = "wss://data-stream.binance.vision";
var ALGO_REST_API_PROD_URL = "https://api.binance.com";
var ALGO_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var AUTO_INVEST_REST_API_PROD_URL = "https://api.binance.com";
var AUTO_INVEST_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var C2C_REST_API_PROD_URL = "https://api.binance.com";
var C2C_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var CONVERT_REST_API_PROD_URL = "https://api.binance.com";
var CONVERT_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var COPY_TRADING_REST_API_PROD_URL = "https://api.binance.com";
var COPY_TRADING_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var CRYPTO_LOAN_REST_API_PROD_URL = "https://api.binance.com";
var CRYPTO_LOAN_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var DERIVATIVES_TRADING_COIN_FUTURES_REST_API_PROD_URL = "https://dapi.binance.com";
var DERIVATIVES_TRADING_COIN_FUTURES_REST_API_TESTNET_URL = "https://testnet.binancefuture.com";
var DERIVATIVES_TRADING_COIN_FUTURES_WS_API_PROD_URL = "wss://ws-dapi.binance.com/ws-dapi/v1";
var DERIVATIVES_TRADING_COIN_FUTURES_WS_API_TESTNET_URL = "wss://testnet.binancefuture.com/ws-dapi/v1";
var DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_PROD_URL = "wss://dstream.binance.com";
var DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_TESTNET_URL = "wss://dstream.binancefuture.com";
var DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL = "https://fapi.binance.com";
var DERIVATIVES_TRADING_USDS_FUTURES_REST_API_TESTNET_URL = "https://testnet.binancefuture.com";
var DERIVATIVES_TRADING_USDS_FUTURES_WS_API_PROD_URL = "wss://ws-fapi.binance.com/ws-fapi/v1";
var DERIVATIVES_TRADING_USDS_FUTURES_WS_API_TESTNET_URL = "wss://testnet.binancefuture.com/ws-fapi/v1";
var DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_PROD_URL = "wss://fstream.binance.com";
var DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_TESTNET_URL = "wss://stream.binancefuture.com";
var DERIVATIVES_TRADING_OPTIONS_REST_API_PROD_URL = "https://eapi.binance.com";
var DERIVATIVES_TRADING_OPTIONS_WS_STREAMS_PROD_URL = "wss://nbstream.binance.com/eoptions";
var DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_PROD_URL = "https://papi.binance.com";
var DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_TESTNET_URL = "https://testnet.binancefuture.com";
var DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_PROD_URL = "https://fapi.binance.com";
var DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_TESTNET_URL = "https://testnet.binancefuture.com";
var DUAL_INVESTMENT_REST_API_PROD_URL = "https://api.binance.com";
var DUAL_INVESTMENT_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var FIAT_REST_API_PROD_URL = "https://api.binance.com";
var FIAT_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var GIFT_CARD_REST_API_PROD_URL = "https://api.binance.com";
var GIFT_CARD_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var MARGIN_TRADING_REST_API_PROD_URL = "https://api.binance.com";
var MARGIN_TRADING_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var MINING_REST_API_PROD_URL = "https://api.binance.com";
var MINING_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var NFT_REST_API_PROD_URL = "https://api.binance.com";
var NFT_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var PAY_REST_API_PROD_URL = "https://api.binance.com";
var PAY_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var REBATE_REST_API_PROD_URL = "https://api.binance.com";
var REBATE_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var SIMPLE_EARN_REST_API_PROD_URL = "https://api.binance.com";
var SIMPLE_EARN_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var STAKING_REST_API_PROD_URL = "https://api.binance.com";
var STAKING_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var SUB_ACCOUNT_REST_API_PROD_URL = "https://api.binance.com";
var SUB_ACCOUNT_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var VIP_LOAN_REST_API_PROD_URL = "https://api.binance.com";
var VIP_LOAN_REST_API_TESTNET_URL = "https://testnet.binance.vision";
var WALLET_REST_API_PROD_URL = "https://api.binance.com";
var WALLET_REST_API_TESTNET_URL = "https://testnet.binance.vision";

// src/errors.ts
var ConnectorClientError = class _ConnectorClientError extends Error {
  constructor(msg) {
    super(msg || "An unexpected error occurred.");
    Object.setPrototypeOf(this, _ConnectorClientError.prototype);
    this.name = "ConnectorClientError";
  }
};
var RequiredError = class _RequiredError extends Error {
  constructor(field, msg) {
    super(msg || `Required parameter ${field} was null or undefined.`);
    this.field = field;
    Object.setPrototypeOf(this, _RequiredError.prototype);
    this.name = "RequiredError";
  }
};
var UnauthorizedError = class _UnauthorizedError extends Error {
  constructor(msg) {
    super(msg || "Unauthorized access. Authentication required.");
    Object.setPrototypeOf(this, _UnauthorizedError.prototype);
    this.name = "UnauthorizedError";
  }
};
var ForbiddenError = class _ForbiddenError extends Error {
  constructor(msg) {
    super(msg || "Access to the requested resource is forbidden.");
    Object.setPrototypeOf(this, _ForbiddenError.prototype);
    this.name = "ForbiddenError";
  }
};
var TooManyRequestsError = class _TooManyRequestsError extends Error {
  constructor(msg) {
    super(msg || "Too many requests. You are being rate-limited.");
    Object.setPrototypeOf(this, _TooManyRequestsError.prototype);
    this.name = "TooManyRequestsError";
  }
};
var RateLimitBanError = class _RateLimitBanError extends Error {
  constructor(msg) {
    super(msg || "The IP address has been banned for exceeding rate limits.");
    Object.setPrototypeOf(this, _RateLimitBanError.prototype);
    this.name = "RateLimitBanError";
  }
};
var ServerError = class _ServerError extends Error {
  constructor(msg, statusCode) {
    super(msg || "An internal server error occurred.");
    this.statusCode = statusCode;
    Object.setPrototypeOf(this, _ServerError.prototype);
    this.name = "ServerError";
  }
};
var NetworkError = class _NetworkError extends Error {
  constructor(msg) {
    super(msg || "A network error occurred.");
    Object.setPrototypeOf(this, _NetworkError.prototype);
    this.name = "NetworkError";
  }
};
var NotFoundError = class _NotFoundError extends Error {
  constructor(msg) {
    super(msg || "The requested resource was not found.");
    Object.setPrototypeOf(this, _NotFoundError.prototype);
    this.name = "NotFoundError";
  }
};
var BadRequestError = class _BadRequestError extends Error {
  constructor(msg) {
    super(msg || "The request was invalid or cannot be otherwise served.");
    Object.setPrototypeOf(this, _BadRequestError.prototype);
    this.name = "BadRequestError";
  }
};

// src/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["NONE"] = "";
  LogLevel2["DEBUG"] = "debug";
  LogLevel2["INFO"] = "info";
  LogLevel2["WARN"] = "warn";
  LogLevel2["ERROR"] = "error";
  return LogLevel2;
})(LogLevel || {});
var Logger = class _Logger {
  constructor() {
    this.minLogLevel = "info" /* INFO */;
    this.levelsOrder = [
      "" /* NONE */,
      "debug" /* DEBUG */,
      "info" /* INFO */,
      "warn" /* WARN */,
      "error" /* ERROR */
    ];
  }
  static getInstance() {
    if (!_Logger.instance) {
      _Logger.instance = new _Logger();
    }
    return _Logger.instance;
  }
  setMinLogLevel(level) {
    if (!this.isValidLogLevel(level)) {
      throw new Error(`Invalid log level: ${level}`);
    }
    this.minLogLevel = level;
  }
  isValidLogLevel(level) {
    return this.levelsOrder.includes(level);
  }
  log(level, ...message) {
    if (level === "" /* NONE */ || !this.allowLevelLog(level)) {
      return;
    }
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    console[level](`[${timestamp}] [${level.toLowerCase()}]`, ...message);
  }
  allowLevelLog(level) {
    if (!this.isValidLogLevel(level)) {
      throw new Error(`Invalid log level: ${level}`);
    }
    const currentLevelIndex = this.levelsOrder.indexOf(level);
    const minLevelIndex = this.levelsOrder.indexOf(this.minLogLevel);
    return currentLevelIndex >= minLevelIndex;
  }
  debug(...message) {
    this.log("debug" /* DEBUG */, ...message);
  }
  info(...message) {
    this.log("info" /* INFO */, ...message);
  }
  warn(...message) {
    this.log("warn" /* WARN */, ...message);
  }
  error(...message) {
    this.log("error" /* ERROR */, ...message);
  }
};

// src/utils.ts
var import_crypto = __toESM(require("crypto"));
var import_fs = __toESM(require("fs"));
var import_https = __toESM(require("https"));
var import_axios = __toESM(require("axios"));
function buildQueryString(params) {
  if (!params)
    return "";
  return Object.entries(params).map(stringifyKeyValuePair).join("&");
}
function stringifyKeyValuePair([key, value]) {
  const valueString = Array.isArray(value) ? `["${value.join('","')}"]` : value;
  return `${key}=${encodeURIComponent(valueString)}`;
}
function randomString() {
  return import_crypto.default.randomBytes(16).toString("hex");
}
function validateTimeUnit(timeUnit) {
  if (!timeUnit) {
    return;
  } else if (timeUnit !== TimeUnit.MILLISECOND && timeUnit !== TimeUnit.MICROSECOND && timeUnit !== TimeUnit.millisecond && timeUnit !== TimeUnit.microsecond) {
    throw new Error("timeUnit must be either 'MILLISECOND' or 'MICROSECOND'");
  }
  return timeUnit;
}
async function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function getTimestamp() {
  return Date.now();
}
var getSignature = function(configuration, queryParams) {
  const params = buildQueryString(queryParams);
  let signature = "";
  if (configuration?.apiSecret && !configuration?.privateKey) {
    signature = import_crypto.default.createHmac("sha256", configuration.apiSecret).update(params).digest("hex");
  } else if (configuration?.privateKey) {
    let privateKey = configuration.privateKey;
    if (typeof privateKey === "string" && import_fs.default.existsSync(privateKey)) {
      privateKey = import_fs.default.readFileSync(privateKey, "utf-8");
    }
    let keyObject;
    try {
      const privateKeyObj = { key: privateKey };
      if (configuration.privateKeyPassphrase && typeof configuration.privateKeyPassphrase === "string") {
        privateKeyObj.passphrase = configuration.privateKeyPassphrase;
      }
      keyObject = import_crypto.default.createPrivateKey(privateKeyObj);
    } catch {
      throw new Error(
        "Invalid private key. Please provide a valid RSA or ED25519 private key."
      );
    }
    const keyType = keyObject.asymmetricKeyType;
    if (keyType === "rsa") {
      signature = import_crypto.default.sign("RSA-SHA256", Buffer.from(params), keyObject).toString("base64");
    } else if (keyType === "ed25519") {
      signature = import_crypto.default.sign(null, Buffer.from(params), keyObject).toString("base64");
    } else {
      throw new Error("Unsupported private key type. Must be RSA or ED25519.");
    }
  } else {
    throw new Error("Either 'apiSecret' or 'privateKey' must be provided for signed requests.");
  }
  return signature;
};
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (parameter == null)
    return;
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, String(parameter));
    } else {
      urlSearchParams.set(key, String(parameter));
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var shouldRetryRequest = function(error, method, retriesLeft) {
  const isRetriableMethod = ["GET", "DELETE"].includes(method ?? "");
  const isRetriableStatus = [500, 502, 503, 504].includes(
    error?.response?.status ?? 0
  );
  return (retriesLeft ?? 0) > 0 && isRetriableMethod && (isRetriableStatus || !error?.response);
};
var httpRequestFunction = async function(axiosArgs, configuration) {
  const axiosRequestArgs = {
    ...axiosArgs.options,
    url: (import_axios.default.defaults?.baseURL ? "" : configuration?.basePath ?? "") + axiosArgs.url
  };
  if (configuration?.keepAlive) {
    axiosRequestArgs.httpsAgent = new import_https.default.Agent({
      ...configuration?.httpsAgent instanceof import_https.default.Agent ? configuration.httpsAgent.options : {},
      keepAlive: true
    });
  }
  if (configuration?.compression) {
    axiosRequestArgs.headers = {
      ...axiosRequestArgs.headers,
      "Accept-Encoding": "gzip, deflate, br"
    };
  }
  const retries = configuration?.retries ?? 0;
  const backoff = configuration?.backoff ?? 0;
  let attempt = 0;
  while (attempt <= retries) {
    try {
      const response = await import_axios.default.request({
        ...axiosRequestArgs,
        responseType: "text"
      });
      const rateLimits = parseRateLimitHeaders(response.headers);
      return {
        data: async () => JSON.parse(response.data),
        status: response.status,
        headers: response.headers,
        rateLimits
      };
    } catch (error) {
      attempt++;
      if (shouldRetryRequest(
        error,
        axiosRequestArgs?.method?.toUpperCase(),
        retries - attempt
      )) {
        await delay(backoff * attempt);
      } else {
        if (error.response) {
          const status = error.response?.status;
          const data = JSON.parse(
            error.response?.data ?? "{}"
          );
          switch (status) {
            case 400:
              throw new BadRequestError(data?.msg);
            case 401:
              throw new UnauthorizedError(data?.msg);
            case 403:
              throw new ForbiddenError(data?.msg);
            case 404:
              throw new NotFoundError(data?.msg);
            case 418:
              throw new RateLimitBanError(data?.msg);
            case 429:
              throw new TooManyRequestsError(data?.msg);
            default:
              if (status >= 500 && status < 600)
                throw new ServerError(`Server error: ${status}`, status);
              throw new ConnectorClientError(data?.msg);
          }
        } else {
          throw new NetworkError("Network error or request timeout.");
        }
      }
    }
  }
  throw new Error(`Request failed after ${retries} retries`);
};
var parseRateLimitHeaders = function(headers) {
  const rateLimits = [];
  const parseIntervalDetails = (key) => {
    const match = key.match(/x-mbx-used-weight-(\d+)([smhd])|x-mbx-order-count-(\d+)([smhd])/i);
    if (!match)
      return null;
    const intervalNum = parseInt(match[1] || match[3], 10);
    const intervalLetter = (match[2] || match[4])?.toUpperCase();
    let interval;
    switch (intervalLetter) {
      case "S":
        interval = "SECOND";
        break;
      case "M":
        interval = "MINUTE";
        break;
      case "H":
        interval = "HOUR";
        break;
      case "D":
        interval = "DAY";
        break;
      default:
        return null;
    }
    return { interval, intervalNum };
  };
  for (const [key, value] of Object.entries(headers)) {
    const normalizedKey = key.toLowerCase();
    if (value === void 0)
      continue;
    if (normalizedKey.startsWith("x-mbx-used-weight-")) {
      const details = parseIntervalDetails(normalizedKey);
      if (details) {
        rateLimits.push({
          rateLimitType: "REQUEST_WEIGHT",
          interval: details.interval,
          intervalNum: details.intervalNum,
          count: parseInt(value, 10)
        });
      }
    } else if (normalizedKey.startsWith("x-mbx-order-count-")) {
      const details = parseIntervalDetails(normalizedKey);
      if (details) {
        rateLimits.push({
          rateLimitType: "ORDERS",
          interval: details.interval,
          intervalNum: details.intervalNum,
          count: parseInt(value, 10)
        });
      }
    }
  }
  if (headers["retry-after"]) {
    const retryAfter = parseInt(headers["retry-after"], 10);
    for (const limit of rateLimits) {
      limit.retryAfter = retryAfter;
    }
  }
  return rateLimits;
};
var sendRequest = function(configuration, endpoint, method, params = {}, timeUnit, options = {}) {
  const localVarUrlObj = new URL(endpoint, configuration?.basePath);
  const localVarRequestOptions = {
    method,
    ...configuration?.baseOptions
  };
  const localVarQueryParameter = { ...params };
  if (options.isSigned) {
    const timestamp = getTimestamp();
    localVarQueryParameter["timestamp"] = timestamp;
    const signature = getSignature(configuration, localVarQueryParameter);
    if (signature) {
      localVarQueryParameter["signature"] = signature;
    }
  }
  setSearchParams(localVarUrlObj, localVarQueryParameter);
  if (timeUnit && localVarRequestOptions.headers) {
    const _timeUnit = validateTimeUnit(timeUnit);
    localVarRequestOptions.headers = {
      ...localVarRequestOptions.headers,
      "X-MBX-TIME-UNIT": _timeUnit
    };
  }
  return httpRequestFunction(
    {
      url: toPathString(localVarUrlObj),
      options: localVarRequestOptions
    },
    configuration
  );
};
function removeEmptyValue(obj) {
  if (!(obj instanceof Object))
    return {};
  return Object.fromEntries(
    Object.entries(obj).filter(
      ([, value]) => value !== null && value !== void 0 && value !== ""
    )
  );
}
function sortObject(obj) {
  return Object.keys(obj).sort().reduce((res, key) => {
    res[key] = obj[key];
    return res;
  }, {});
}
function replaceWebsocketStreamsPlaceholders(str, variables) {
  const normalizedVariables = Object.keys(variables).reduce(
    (acc, key) => {
      acc[key.toLowerCase().replace(/[-_]/g, "")] = variables[key];
      return acc;
    },
    {}
  );
  return str.replace(/<([^>]+)>/g, (match, fieldName) => {
    const normalizedFieldName = fieldName.toLowerCase().replace(/[-_]/g, "");
    if (Object.prototype.hasOwnProperty.call(normalizedVariables, normalizedFieldName) && normalizedVariables[normalizedFieldName] != null) {
      const value = normalizedVariables[normalizedFieldName];
      switch (normalizedFieldName) {
        case "symbol":
        case "windowsize":
          return value.toLowerCase();
        case "updatespeed":
          return `@${value}`;
        default:
          return value;
      }
    }
    return "";
  });
}
function createStreamHandler(websocketBase, stream, id) {
  websocketBase.subscribe(stream, id);
  let registeredCallback;
  return {
    on: (event, callback) => {
      if (event === "message") {
        registeredCallback = (data) => callback(data);
        const callbackSet = websocketBase.streamCallbackMap.get(stream) ?? /* @__PURE__ */ new Set();
        callbackSet.add(registeredCallback);
        websocketBase.streamCallbackMap.set(stream, callbackSet);
      }
    },
    unsubscribe: () => {
      if (registeredCallback)
        websocketBase.streamCallbackMap.get(stream)?.delete(registeredCallback);
      websocketBase.unsubscribe(stream, id);
    }
  };
}

// src/websocket.ts
var import_events = require("events");
var import_ws = __toESM(require("ws"));
var WebsocketEventEmitter = class {
  constructor() {
    this.eventEmitter = new import_events.EventEmitter();
  }
  /* eslint-disable @typescript-eslint/no-explicit-any */
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  /* eslint-disable @typescript-eslint/no-explicit-any */
  off(event, listener) {
    this.eventEmitter.off(event, listener);
  }
  /* eslint-disable @typescript-eslint/no-explicit-any */
  emit(event, ...args) {
    this.eventEmitter.emit(event, ...args);
  }
};
var _WebsocketCommon = class _WebsocketCommon extends WebsocketEventEmitter {
  constructor(configuration, connectionPool = []) {
    super();
    this.configuration = configuration;
    this.connectionQueue = [];
    this.queueProcessing = false;
    this.connectionTimers = /* @__PURE__ */ new Map();
    this.roundRobinIndex = 0;
    this.logger = Logger.getInstance();
    this.connectionPool = connectionPool;
    this.mode = this.configuration?.mode ?? "single";
    this.poolSize = this.mode === "pool" && this.configuration?.poolSize ? this.configuration.poolSize : 1;
    if (!connectionPool || connectionPool.length === 0)
      this.initializePool(this.poolSize);
  }
  /**
   * Initializes the WebSocket connection pool by creating a specified number of connection objects
   * and adding them to the `connectionPool` array. Each connection object has the following properties:
   * - `closeInitiated`: a boolean indicating whether the connection has been closed
   * - `reconnectionPending`: a boolean indicating whether a reconnection is pending
   * - `pendingRequests`: a Map that tracks pending requests for the connection
   * @param size - The number of connection objects to create and add to the pool.
   * @returns void
   */
  initializePool(size) {
    for (let i = 0; i < size; i++) {
      this.connectionPool.push({
        id: randomString(),
        closeInitiated: false,
        reconnectionPending: false,
        renewalPending: false,
        pendingRequests: /* @__PURE__ */ new Map(),
        pendingSubscriptions: []
      });
    }
  }
  /**
   * Gets a WebSocket connection from the pool or single connection.
   * If the connection mode is 'single', it returns the first connection in the pool.
   * If the connection mode is 'pool', it returns an available connection from the pool,
   * using a round-robin selection strategy. If no available connections are found, it throws an error.
   * @param allowNonEstablishedWebsockets - A boolean indicating whether to allow connections that are not established.
   * @returns {WebsocketConnection} The selected WebSocket connection.
   */
  getConnection(allowNonEstablishedWebsockets = false) {
    if (this.mode === "single")
      return this.connectionPool[0];
    const availableConnections = this.connectionPool.filter(
      (connection) => this.isConnectionReady(connection, allowNonEstablishedWebsockets)
    );
    if (availableConnections.length === 0) {
      throw new Error("No available Websocket connections are ready.");
    }
    const selectedConnection = availableConnections[this.roundRobinIndex % availableConnections.length];
    this.roundRobinIndex = (this.roundRobinIndex + 1) % availableConnections.length;
    return selectedConnection;
  }
  /**
   * Checks if the provided WebSocket connection is ready for use.
   * A connection is considered ready if it is open, has no pending reconnection, and has not been closed.
   * @param connection - The WebSocket connection to check.
   * @param allowNonEstablishedWebsockets - An optional flag to allow non-established WebSocket connections.
   * @returns `true` if the connection is ready, `false` otherwise.
   */
  isConnectionReady(connection, allowNonEstablishedWebsockets = false) {
    return (allowNonEstablishedWebsockets || connection.ws?.readyState === import_ws.default.OPEN) && !connection.reconnectionPending && !connection.closeInitiated;
  }
  /**
   * Schedules a timer for a WebSocket connection and tracks it
   * @param connection WebSocket client instance
   * @param callback Function to execute when timer triggers
   * @param delay Time in milliseconds before callback execution
   * @param type Timer type ('timeout' or 'interval')
   * @returns Timer handle
   */
  scheduleTimer(connection, callback, delay2, type = "timeout") {
    const timer = type === "timeout" ? setTimeout(callback, delay2) : setInterval(callback, delay2);
    if (!this.connectionTimers.has(connection))
      this.connectionTimers.set(connection, /* @__PURE__ */ new Set());
    this.connectionTimers.get(connection)?.add({ timer, type });
    return timer;
  }
  /**
   * Clears all timers associated with a WebSocket connection.
   * @param connection - The WebSocket client instance to clear timers for.
   * @returns void
   */
  clearTimers(connection) {
    const timers = this.connectionTimers.get(connection);
    if (timers) {
      timers.forEach(({ timer, type }) => {
        if (type === "timeout")
          clearTimeout(timer);
        else if (type === "interval")
          clearInterval(timer);
      });
      this.connectionTimers.delete(connection);
    }
  }
  /**
   * Processes the connection queue, reconnecting or renewing connections as needed.
   * This method is responsible for iterating through the connection queue and initiating
   * the reconnection or renewal process for each connection in the queue. It throttles
   * the queue processing to avoid overwhelming the server with too many connection
   * requests at once.
   * @param throttleRate - The time in milliseconds to wait between processing each
   * connection in the queue.
   * @returns A Promise that resolves when the queue has been fully processed.
   */
  async processQueue(throttleRate = 1e3) {
    if (this.queueProcessing)
      return;
    this.queueProcessing = true;
    while (this.connectionQueue.length > 0) {
      const { connection, url, isRenewal } = this.connectionQueue.shift();
      this.initConnect(url, isRenewal, connection);
      await delay(throttleRate);
    }
    this.queueProcessing = false;
  }
  /**
   * Enqueues a reconnection or renewal for a WebSocket connection.
   * This method adds the connection, URL, and renewal flag to the connection queue,
   * and then calls the `processQueue` method to initiate the reconnection or renewal
   * process.
   * @param connection - The WebSocket connection to reconnect or renew.
   * @param url - The URL to use for the reconnection or renewal.
   * @param isRenewal - A flag indicating whether this is a renewal (true) or a reconnection (false).
   */
  enqueueReconnection(connection, url, isRenewal) {
    this.connectionQueue.push({ connection, url, isRenewal });
    this.processQueue();
  }
  /**
   * Gracefully closes a WebSocket connection after pending requests complete.
   * This method waits for any pending requests to complete before closing the connection.
   * It sets up a timeout to force-close the connection after 30 seconds if the pending requests
   * do not complete. Once all pending requests are completed, the connection is closed.
   * @param connectionToClose - The WebSocket client instance to close.
   * @param WebsocketConnectionToClose - The WebSocket connection to close.
   * @param connection - The WebSocket connection to close.
   * @returns Promise that resolves when the connection is closed.
   */
  async closeConnectionGracefully(WebsocketConnectionToClose, connection) {
    if (!WebsocketConnectionToClose || !connection)
      return;
    this.logger.debug("Waiting for pending requests to complete before disconnecting.");
    const closePromise = new Promise((resolve) => {
      this.scheduleTimer(
        WebsocketConnectionToClose,
        () => {
          this.logger.warn("Force-closing connection after 30 seconds.");
          resolve();
        },
        3e4
      );
      this.scheduleTimer(
        WebsocketConnectionToClose,
        () => {
          if (connection.pendingRequests.size === 0) {
            this.logger.debug("All pending requests completed, closing connection.");
            resolve();
          }
        },
        1e3,
        "interval"
      );
    });
    await closePromise;
    this.logger.info("Closing Websocket connection.");
    WebsocketConnectionToClose.close();
    this.cleanup(WebsocketConnectionToClose);
  }
  /**
   * Cleans up WebSocket connection resources.
   * Removes all listeners and clears any associated timers for the provided WebSocket client.
   * @param ws - The WebSocket client to clean up.
   * @returns void
   */
  cleanup(ws) {
    if (ws) {
      ws.removeAllListeners();
      this.clearTimers(ws);
    }
  }
  /**
   * Handles incoming WebSocket messages
   * @param data Raw message data received
   * @param connection Websocket connection
   */
  onMessage(data, connection) {
    this.emit("message", data.toString(), connection);
  }
  /**
   * Handles the opening of a WebSocket connection.
   * @param url - The URL of the WebSocket server.
   * @param targetConnection - The WebSocket connection being opened.
   * @param oldConnection - The previous WebSocket connection, if this is a renewal.
   * @param isRenewal - Indicates whether this is a connection renewal.
   * @param oldWSConnection - The WebSocket client instance associated with the old connection.
   */
  onOpen(url, targetConnection, oldWSConnection) {
    this.logger.info(
      `Connected to the Websocket Server with id ${targetConnection.id}: ${url}`
    );
    if (targetConnection.renewalPending) {
      targetConnection.renewalPending = false;
      this.closeConnectionGracefully(oldWSConnection, targetConnection);
    } else if (targetConnection.closeInitiated) {
      this.closeConnectionGracefully(targetConnection.ws, targetConnection);
    } else {
      this.emit("open", this);
    }
  }
  /**
   * Returns the URL to use when reconnecting.
   * Derived classes should override this to provide dynamic URLs.
   * @param defaultURL The URL originally passed during the first connection.
   * @param targetConnection The WebSocket connection being connected.
   * @returns The URL to reconnect to.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getReconnectURL(defaultURL, targetConnection) {
    return defaultURL;
  }
  /**
   * Connects all WebSocket connections in the pool
   * @param url - The Websocket server URL.
   * @returns A promise that resolves when all connections are established.
   */
  async connectPool(url) {
    const connectPromises = this.connectionPool.map(
      (connection) => new Promise((resolve, reject) => {
        this.initConnect(url, false, connection);
        connection.ws?.on("open", () => resolve());
        connection.ws?.on("error", (err) => reject(err));
        connection.ws?.on(
          "close",
          () => reject(new Error("Connection closed unexpectedly."))
        );
      })
    );
    await Promise.all(connectPromises);
  }
  /**
   * Creates a new WebSocket client instance.
   * @param url - The URL to connect to.
   * @returns A new WebSocket client instance.
   */
  createWebSocket(url) {
    return new import_ws.default(url, {
      perMessageDeflate: this.configuration?.compression,
      agent: this.configuration?.agent
    });
  }
  /**
   * Initializes a WebSocket connection.
   * @param url - The Websocket server URL.
   * @param isRenewal - Whether this is a connection renewal.
   * @param connection - An optional WebSocket connection to use.
   * @returns The WebSocket connection.
   */
  initConnect(url, isRenewal = false, connection) {
    const targetConnection = connection || this.getConnection();
    if (targetConnection.renewalPending && isRenewal) {
      this.logger.warn(
        `Connection renewal with id ${targetConnection.id} is already in progress`
      );
      return;
    }
    if (targetConnection.ws && targetConnection.ws.readyState === import_ws.default.OPEN && !isRenewal) {
      this.logger.warn(`Connection with id ${targetConnection.id} already exists`);
      return;
    }
    const ws = this.createWebSocket(url);
    this.logger.info(
      `Establishing Websocket connection with id ${targetConnection.id} to: ${url}`
    );
    if (isRenewal)
      targetConnection.renewalPending = true;
    else
      targetConnection.ws = ws;
    this.scheduleTimer(
      ws,
      () => {
        this.logger.info(`Renewing Websocket connection with id ${targetConnection.id}`);
        this.enqueueReconnection(
          targetConnection,
          this.getReconnectURL(url, targetConnection),
          true
        );
      },
      _WebsocketCommon.MAX_CONNECTION_DURATION
    );
    ws.on("open", () => {
      const oldWSConnection = targetConnection.ws;
      if (targetConnection.renewalPending)
        targetConnection.ws = ws;
      this.onOpen(url, targetConnection, oldWSConnection);
    });
    ws.on("message", (data) => {
      this.onMessage(data.toString(), targetConnection);
    });
    ws.on("ping", () => {
      this.logger.info("Received PING from server");
      this.emit("ping");
      ws.pong();
      this.logger.info("Responded PONG to server's PING message");
    });
    ws.on("pong", () => {
      this.logger.info("Received PONG from server");
      this.emit("pong");
    });
    ws.on("error", (err) => {
      this.logger.error("Received error from server");
      this.logger.error(err);
      this.emit("error", err);
    });
    ws.on("close", (closeEventCode, reason) => {
      this.emit("close", closeEventCode, reason);
      if (!targetConnection.closeInitiated && !isRenewal) {
        this.logger.warn(
          `Connection with id ${targetConnection.id} closed due to ${closeEventCode}: ${reason}`
        );
        this.scheduleTimer(
          ws,
          () => {
            this.logger.info(
              `Reconnecting conection with id ${targetConnection.id} to the server.`
            );
            targetConnection.reconnectionPending = true;
            this.enqueueReconnection(
              targetConnection,
              this.getReconnectURL(url, targetConnection),
              false
            );
          },
          this.configuration?.reconnectDelay ?? 5e3
        );
      }
    });
    return targetConnection;
  }
  /**
   * Checks if the WebSocket connection is currently open.
   * @param connection - An optional WebSocket connection to check. If not provided, the entire connection pool is checked.
   * @returns `true` if the connection is open, `false` otherwise.
   */
  isConnected(connection) {
    const connectionPool = connection ? [connection] : this.connectionPool;
    return connectionPool.some((connection2) => this.isConnectionReady(connection2));
  }
  /**
   * Disconnects from the WebSocket server.
   * If there is no active connection, a warning is logged.
   * Otherwise, all connections in the connection pool are closed gracefully,
   * and a message is logged indicating that the connection has been disconnected.
   * @returns A Promise that resolves when all connections have been closed.
   * @throws Error if the WebSocket client is not set.
   */
  async disconnect() {
    if (!this.isConnected())
      this.logger.warn("No connection to close.");
    else {
      this.connectionPool.forEach((connection) => {
        connection.closeInitiated = true;
      });
      const disconnectPromises = this.connectionPool.map(
        (connection) => this.closeConnectionGracefully(connection.ws, connection)
      );
      await Promise.all(disconnectPromises);
      this.logger.info("Disconnected with Binance Websocket Server");
    }
  }
  /**
   * Sends a ping message to all connected Websocket servers in the pool.
   * If no connections are ready, a warning is logged.
   * For each active connection, the ping message is sent, and debug logs provide details.
   * @throws Error if a Websocket client is not set for a connection.
   */
  pingServer() {
    const connectedConnections = this.connectionPool.filter(
      (connection) => this.isConnected(connection)
    );
    if (connectedConnections.length === 0) {
      this.logger.warn("Ping only can be sent when connection is ready.");
      return;
    }
    this.logger.info("Sending PING to all connected Websocket servers.");
    connectedConnections.forEach((connection) => {
      if (connection.ws) {
        connection.ws.ping();
        this.logger.debug(`PING sent to connection with id ${connection.id}`);
      } else {
        this.logger.error("WebSocket Client not set for a connection.");
      }
    });
  }
  /**
   * Sends a payload through the WebSocket connection.
   * @param payload - Message to send.
   * @param id - Optional request identifier.
   * @param promiseBased - Whether to return a promise.
   * @param timeout - Timeout duration in milliseconds.
   * @param connection - The WebSocket connection to use.
   * @returns A promise if `promiseBased` is true, void otherwise.
   * @throws Error if not connected or WebSocket client is not set.
   */
  send(payload, id, promiseBased = true, timeout = 5e3, connection) {
    if (!this.isConnected(connection)) {
      const errorMsg = "Send can only be sent when connection is ready.";
      this.logger.warn(errorMsg);
      if (promiseBased)
        return Promise.reject(new Error(errorMsg));
      else
        throw new Error(errorMsg);
    }
    const connectionToUse = connection ?? this.getConnection();
    if (!connectionToUse.ws) {
      const errorMsg = "Websocket Client not set";
      this.logger.error(errorMsg);
      if (promiseBased)
        return Promise.reject(new Error(errorMsg));
      else
        throw new Error(errorMsg);
    }
    connectionToUse.ws.send(payload);
    if (promiseBased) {
      return new Promise((resolve, reject) => {
        if (!id)
          return reject(new Error("id is required for promise-based sending."));
        connectionToUse.pendingRequests.set(id, { resolve, reject });
        this.scheduleTimer(
          connectionToUse.ws,
          () => {
            if (connectionToUse.pendingRequests.has(id)) {
              connectionToUse.pendingRequests.delete(id);
              reject(new Error(`Request timeout for id: ${id}`));
            }
          },
          timeout
        );
      });
    }
  }
};
_WebsocketCommon.MAX_CONNECTION_DURATION = 23 * 60 * 60 * 1e3;
var WebsocketCommon = _WebsocketCommon;
var WebsocketAPIBase = class extends WebsocketCommon {
  constructor(configuration, connectionPool = []) {
    super(configuration, connectionPool);
    this.isConnecting = false;
    this.logger = Logger.getInstance();
    this.configuration = configuration;
  }
  /**
   * Prepares the WebSocket URL by adding optional timeUnit parameter
   * @param wsUrl The base WebSocket URL
   * @returns The formatted WebSocket URL with parameters
   */
  prepareURL(wsUrl) {
    let url = wsUrl;
    if (this?.configuration.timeUnit) {
      try {
        const _timeUnit = validateTimeUnit(this.configuration.timeUnit);
        url = `${url}${url.includes("?") ? "&" : "?"}timeUnit=${_timeUnit}`;
      } catch (err) {
        this.logger.error(err);
      }
    }
    return url;
  }
  /**
   * Processes incoming WebSocket messages
   * @param data The raw message data received
   */
  onMessage(data, connection) {
    try {
      const message = JSON.parse(data);
      const { id, status } = message;
      if (id && connection.pendingRequests.has(id)) {
        const request = connection.pendingRequests.get(id);
        connection.pendingRequests.delete(id);
        if (status && status >= 400) {
          request?.reject(message.error);
        } else {
          const response = { data: message.result };
          if (message?.rateLimits)
            response.rateLimits = message.rateLimits;
          request?.resolve(response);
        }
      } else {
        this.logger.warn("Received response for unknown or timed-out request:", message);
      }
    } catch (error) {
      this.logger.error("Failed to parse WebSocket message:", data, error);
    }
    super.onMessage(data, connection);
  }
  /**
   * Establishes a WebSocket connection to Binance
   * @returns Promise that resolves when connection is established
   * @throws Error if connection times out
   */
  connect() {
    if (this.isConnected()) {
      this.logger.info("WebSocket connection already established");
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      if (this.isConnecting)
        return;
      this.isConnecting = true;
      const timeout = setTimeout(() => {
        this.isConnecting = false;
        reject(new Error("Websocket connection timed out"));
      }, 1e4);
      this.connectPool(this.prepareURL(this.configuration.wsURL)).then(() => {
        clearTimeout(timeout);
        this.isConnecting = false;
        resolve();
      }).catch((error) => {
        clearTimeout(timeout);
        this.isConnecting = false;
        reject(error);
      });
    });
  }
  /**
   * Sends a message to the WebSocket API Server.
   * Supports both signed and unsigned messages.
   * @param method The API method to call
   * @param payload Message parameters and options
   * @param options Additional requests options (withApiKey, isSigned)
   * @returns Promise that resolves with the server response
   * @throws Error if not connected
   */
  sendMessage(method, payload = {}, options = {}) {
    if (!this.isConnected()) {
      return Promise.reject(new Error("Not connected"));
    }
    const id = payload.id && /^[0-9a-f]{32}$/.test(payload.id) ? payload.id : randomString();
    delete payload.id;
    let params = removeEmptyValue(payload);
    if (options.withApiKey || options.isSigned) {
      params.apiKey = this.configuration.apiKey;
    }
    if (options.isSigned) {
      params.timestamp = getTimestamp();
      params = sortObject(params);
      params.signature = getSignature(this.configuration, params);
    }
    const data = {
      id,
      method,
      params
    };
    this.logger.debug("Send message to Binance WebSocket API Server:", data);
    return this.send(JSON.stringify(data), id, true, this.configuration?.timeout);
  }
};
var WebsocketStreamsBase2 = class extends WebsocketCommon {
  constructor(configuration, connectionPool = []) {
    super(configuration, connectionPool);
    this.streamConnectionMap = /* @__PURE__ */ new Map();
    this.streamCallbackMap = /* @__PURE__ */ new Map();
    this.logger = Logger.getInstance();
    this.configuration = configuration;
    this.wsURL = configuration.wsURL;
  }
  /**
   * Formats the WebSocket URL for a given stream or streams.
   * @param streams - Array of stream names to include in the URL.
   * @returns The formatted WebSocket URL with the provided streams.
   */
  prepareURL(streams = []) {
    let url = `${this.wsURL}/stream?streams=${streams.join("/")}`;
    if (this.configuration?.timeUnit) {
      try {
        const _timeUnit = validateTimeUnit(this.configuration.timeUnit);
        url = `${url}${url.includes("?") ? "&" : "?"}timeUnit=${_timeUnit}`;
      } catch (err) {
        this.logger.error(err);
      }
    }
    return url;
  }
  /**
   * Formats the WebSocket URL with stream and configuration parameters to be used for reconnection.
   * @param url - The base WebSocket URL.
   * @param targetConnection - The target WebSocket connection.
   * @returns The formatted WebSocket URL with streams and optional parameters.
   */
  getReconnectURL(url, targetConnection) {
    const streams = Array.from(this.streamConnectionMap.keys()).filter(
      (stream) => this.streamConnectionMap.get(stream) === targetConnection
    );
    return this.prepareURL(streams);
  }
  /**
   * Handles subscription to streams and assigns them to specific connections
   * @param streams Array of stream names to subscribe to
   * @returns Map of connections to streams
   */
  handleStreamAssignment(streams) {
    const connectionStreamMap = /* @__PURE__ */ new Map();
    streams.forEach((stream) => {
      if (!this.streamCallbackMap.has(stream))
        this.streamCallbackMap.set(stream, /* @__PURE__ */ new Set());
      let connection = this.streamConnectionMap.get(stream);
      if (!connection || connection.closeInitiated || connection.reconnectionPending) {
        connection = this.getConnection(true);
        this.streamConnectionMap.set(stream, connection);
      }
      if (!connectionStreamMap.has(connection))
        connectionStreamMap.set(connection, []);
      connectionStreamMap.get(connection)?.push(stream);
    });
    return connectionStreamMap;
  }
  /**
   * Sends a subscription payload for specified streams on a given connection.
   * @param connection The WebSocket connection to use for sending the subscription.
   * @param streams The streams to subscribe to.
   * @param id Optional ID for the subscription.
   */
  sendSubscriptionPayload(connection, streams, id) {
    const payload = {
      method: "SUBSCRIBE",
      params: streams,
      id: id && /^[0-9a-f]{32}$/.test(id) ? id : randomString()
    };
    this.logger.info("SUBSCRIBE", payload);
    this.send(JSON.stringify(payload), void 0, false, 0, connection);
  }
  /**
   * Processes pending subscriptions for a given connection.
   * Sends all queued subscriptions in a single payload.
   * @param connection The WebSocket connection to process.
   */
  processPendingSubscriptions(connection) {
    if (connection.pendingSubscriptions && connection.pendingSubscriptions.length > 0) {
      this.logger.info("Processing queued subscriptions for connection");
      this.sendSubscriptionPayload(connection, connection.pendingSubscriptions);
      connection.pendingSubscriptions = [];
    }
  }
  /**
   * Handles incoming WebSocket messages, parsing the data and invoking the appropriate callback function.
   * If the message contains a stream name that is registered in the `streamCallbackMap`, the corresponding
   * callback function is called with the message data.
   * If the message cannot be parsed, an error is logged.
   * @param data The raw WebSocket message data.
   * @param connection The WebSocket connection that received the message.
   */
  onMessage(data, connection) {
    try {
      const parsedData = JSON.parse(data);
      const streamName = parsedData?.stream;
      if (streamName && this.streamCallbackMap.has(streamName))
        this.streamCallbackMap.get(streamName)?.forEach((callback) => callback(parsedData.data));
    } catch (error) {
      this.logger.error("Failed to parse WebSocket message:", data, error);
    }
    super.onMessage(data, connection);
  }
  /**
   * Called when the WebSocket connection is opened.
   * Processes any pending subscriptions for the target connection.
   * @param url The URL of the WebSocket connection.
   * @param targetConnection The WebSocket connection that was opened.
   * @param oldConnection The previous WebSocket connection, if any.
   * @param isRenewal Whether the connection is a renewal of an existing connection.
   */
  onOpen(url, targetConnection, oldWSConnection) {
    this.processPendingSubscriptions(targetConnection);
    super.onOpen(url, targetConnection, oldWSConnection);
  }
  /**
   * Connects to the WebSocket server and subscribes to the specified streams.
   * This method returns a Promise that resolves when the connection is established,
   * or rejects with an error if the connection fails to be established within 10 seconds.
   * @param stream - A single stream name or an array of stream names to subscribe to.
   * @returns A Promise that resolves when the connection is established.
   */
  connect(stream = []) {
    const streams = Array.isArray(stream) ? stream : [stream];
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error("Websocket connection timed out"));
      }, 1e4);
      this.connectPool(this.prepareURL(streams)).then(() => {
        clearTimeout(timeout);
        resolve();
      }).catch((error) => {
        clearTimeout(timeout);
        reject(error);
      });
    });
  }
  /**
   * Disconnects the WebSocket connection and clears the stream callback map.
   * This method is called to clean up the connection and associated resources.
   */
  async disconnect() {
    this.streamCallbackMap.clear();
    this.streamConnectionMap.clear();
    super.disconnect();
  }
  /**
   * Subscribes to one or multiple WebSocket streams
   * Handles both single and pool modes
   * @param stream Single stream name or array of stream names to subscribe to
   * @param id Optional subscription ID
   * @returns void
   */
  subscribe(stream, id) {
    const streams = (Array.isArray(stream) ? stream : [stream]).filter(
      (stream2) => !this.streamConnectionMap.has(stream2)
    );
    const connectionStreamMap = this.handleStreamAssignment(streams);
    connectionStreamMap.forEach((streams2, connection) => {
      if (!this.isConnected(connection)) {
        this.logger.info(
          `Connection is not ready. Queuing subscription for streams: ${streams2}`
        );
        connection.pendingSubscriptions?.push(...streams2);
        return;
      }
      this.sendSubscriptionPayload(connection, streams2, id);
    });
  }
  /**
   * Unsubscribes from one or multiple WebSocket streams
   * Handles both single and pool modes
   * @param stream Single stream name or array of stream names to unsubscribe from
   * @param id Optional unsubscription ID
   * @returns void
   */
  unsubscribe(stream, id) {
    const streams = Array.isArray(stream) ? stream : [stream];
    streams.forEach((stream2) => {
      const connection = this.streamConnectionMap.get(stream2);
      if (!connection || !connection.ws || !this.isConnected(connection)) {
        this.logger.warn(`Stream ${stream2} not associated with an active connection.`);
        return;
      }
      if (!this.streamCallbackMap.has(stream2) || this.streamCallbackMap.get(stream2)?.size === 0) {
        const payload = {
          method: "UNSUBSCRIBE",
          params: [stream2],
          id: id && /^[0-9a-f]{32}$/.test(id) ? id : randomString()
        };
        this.logger.info("UNSUBSCRIBE", payload);
        this.send(JSON.stringify(payload), void 0, false, 0, connection);
        this.streamConnectionMap.delete(stream2);
        this.streamCallbackMap.delete(stream2);
      }
    });
  }
  /**
   * Checks if the specified stream is currently subscribed.
   * @param stream - The name of the stream to check.
   * @returns `true` if the stream is currently subscribed, `false` otherwise.
   */
  isSubscribed(stream) {
    return this.streamConnectionMap.has(stream);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ALGO_REST_API_PROD_URL,
  ALGO_REST_API_TESTNET_URL,
  AUTO_INVEST_REST_API_PROD_URL,
  AUTO_INVEST_REST_API_TESTNET_URL,
  BadRequestError,
  C2C_REST_API_PROD_URL,
  C2C_REST_API_TESTNET_URL,
  CONVERT_REST_API_PROD_URL,
  CONVERT_REST_API_TESTNET_URL,
  COPY_TRADING_REST_API_PROD_URL,
  COPY_TRADING_REST_API_TESTNET_URL,
  CRYPTO_LOAN_REST_API_PROD_URL,
  CRYPTO_LOAN_REST_API_TESTNET_URL,
  ConfigurationRestAPI,
  ConfigurationWebsocketAPI,
  ConfigurationWebsocketStreams,
  ConnectorClientError,
  DERIVATIVES_TRADING_COIN_FUTURES_REST_API_PROD_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_API_PROD_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_API_TESTNET_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_PROD_URL,
  DERIVATIVES_TRADING_COIN_FUTURES_WS_STREAMS_TESTNET_URL,
  DERIVATIVES_TRADING_OPTIONS_REST_API_PROD_URL,
  DERIVATIVES_TRADING_OPTIONS_WS_STREAMS_PROD_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_PROD_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_PRO_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_PROD_URL,
  DERIVATIVES_TRADING_PORTFOLIO_MARGIN_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_REST_API_PROD_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_REST_API_TESTNET_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_API_PROD_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_API_TESTNET_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_PROD_URL,
  DERIVATIVES_TRADING_USDS_FUTURES_WS_STREAMS_TESTNET_URL,
  DUAL_INVESTMENT_REST_API_PROD_URL,
  DUAL_INVESTMENT_REST_API_TESTNET_URL,
  FIAT_REST_API_PROD_URL,
  FIAT_REST_API_TESTNET_URL,
  ForbiddenError,
  GIFT_CARD_REST_API_PROD_URL,
  GIFT_CARD_REST_API_TESTNET_URL,
  LogLevel,
  Logger,
  MARGIN_TRADING_REST_API_PROD_URL,
  MARGIN_TRADING_REST_API_TESTNET_URL,
  MINING_REST_API_PROD_URL,
  MINING_REST_API_TESTNET_URL,
  NFT_REST_API_PROD_URL,
  NFT_REST_API_TESTNET_URL,
  NetworkError,
  NotFoundError,
  PAY_REST_API_PROD_URL,
  PAY_REST_API_TESTNET_URL,
  REBATE_REST_API_PROD_URL,
  REBATE_REST_API_TESTNET_URL,
  RateLimitBanError,
  RequiredError,
  SIMPLE_EARN_REST_API_PROD_URL,
  SIMPLE_EARN_REST_API_TESTNET_URL,
  SPOT_REST_API_MARKET_URL,
  SPOT_REST_API_PROD_URL,
  SPOT_REST_API_TESTNET_URL,
  SPOT_WS_API_PROD_URL,
  SPOT_WS_API_TESTNET_URL,
  SPOT_WS_STREAMS_MARKET_URL,
  SPOT_WS_STREAMS_PROD_URL,
  SPOT_WS_STREAMS_TESTNET_URL,
  STAKING_REST_API_PROD_URL,
  STAKING_REST_API_TESTNET_URL,
  SUB_ACCOUNT_REST_API_PROD_URL,
  SUB_ACCOUNT_REST_API_TESTNET_URL,
  ServerError,
  TimeUnit,
  TooManyRequestsError,
  UnauthorizedError,
  VIP_LOAN_REST_API_PROD_URL,
  VIP_LOAN_REST_API_TESTNET_URL,
  WALLET_REST_API_PROD_URL,
  WALLET_REST_API_TESTNET_URL,
  WebsocketAPIBase,
  WebsocketCommon,
  WebsocketEventEmitter,
  WebsocketStreamsBase,
  assertParamExists,
  buildQueryString,
  createStreamHandler,
  delay,
  getSignature,
  getTimestamp,
  httpRequestFunction,
  parseRateLimitHeaders,
  randomString,
  removeEmptyValue,
  replaceWebsocketStreamsPlaceholders,
  sendRequest,
  setSearchParams,
  shouldRetryRequest,
  sortObject,
  toPathString,
  validateTimeUnit
});
//# sourceMappingURL=index.js.map