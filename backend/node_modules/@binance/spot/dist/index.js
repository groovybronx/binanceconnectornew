"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BadRequestError: () => import_common12.BadRequestError,
  ConnectorClientError: () => import_common12.ConnectorClientError,
  ForbiddenError: () => import_common12.ForbiddenError,
  NetworkError: () => import_common12.NetworkError,
  NotFoundError: () => import_common12.NotFoundError,
  RateLimitBanError: () => import_common12.RateLimitBanError,
  RequiredError: () => import_common12.RequiredError,
  SPOT_REST_API_PROD_URL: () => import_common12.SPOT_REST_API_PROD_URL,
  SPOT_REST_API_TESTNET_URL: () => import_common12.SPOT_REST_API_TESTNET_URL,
  SPOT_WS_API_PROD_URL: () => import_common12.SPOT_WS_API_PROD_URL,
  SPOT_WS_API_TESTNET_URL: () => import_common12.SPOT_WS_API_TESTNET_URL,
  SPOT_WS_STREAMS_PROD_URL: () => import_common12.SPOT_WS_STREAMS_PROD_URL,
  SPOT_WS_STREAMS_TESTNET_URL: () => import_common12.SPOT_WS_STREAMS_TESTNET_URL,
  ServerError: () => import_common12.ServerError,
  Spot: () => Spot,
  SpotRestAPI: () => rest_api_exports,
  SpotWebsocketAPI: () => websocket_api_exports,
  SpotWebsocketStreams: () => websocket_streams_exports,
  TimeUnit: () => import_common12.TimeUnit,
  TooManyRequestsError: () => import_common12.TooManyRequestsError,
  UnauthorizedError: () => import_common12.UnauthorizedError
});
module.exports = __toCommonJS(src_exports);

// src/spot.ts
var import_os = require("os");
var import_common11 = require("@binance/common");

// package.json
var name = "@binance/spot";
var version = "1.0.0";

// src/rest-api/index.ts
var rest_api_exports = {};
__export(rest_api_exports, {
  AccountApi: () => AccountApi,
  DeleteOrderCancelRestrictionsEnum: () => DeleteOrderCancelRestrictionsEnum,
  ExchangeInfoSymbolStatusEnum: () => ExchangeInfoSymbolStatusEnum,
  GeneralApi: () => GeneralApi,
  KlinesIntervalEnum: () => KlinesIntervalEnum,
  MarketApi: () => MarketApi,
  NewOrderNewOrderRespTypeEnum: () => NewOrderNewOrderRespTypeEnum,
  NewOrderSelfTradePreventionModeEnum: () => NewOrderSelfTradePreventionModeEnum,
  NewOrderSideEnum: () => NewOrderSideEnum,
  NewOrderTimeInForceEnum: () => NewOrderTimeInForceEnum,
  NewOrderTypeEnum: () => NewOrderTypeEnum,
  OrderCancelReplaceCancelReplaceModeEnum: () => OrderCancelReplaceCancelReplaceModeEnum,
  OrderCancelReplaceCancelRestrictionsEnum: () => OrderCancelReplaceCancelRestrictionsEnum,
  OrderCancelReplaceNewOrderRespTypeEnum: () => OrderCancelReplaceNewOrderRespTypeEnum,
  OrderCancelReplaceOrderRateLimitExceededModeEnum: () => OrderCancelReplaceOrderRateLimitExceededModeEnum,
  OrderCancelReplaceSelfTradePreventionModeEnum: () => OrderCancelReplaceSelfTradePreventionModeEnum,
  OrderCancelReplaceSideEnum: () => OrderCancelReplaceSideEnum,
  OrderCancelReplaceTimeInForceEnum: () => OrderCancelReplaceTimeInForceEnum,
  OrderCancelReplaceTypeEnum: () => OrderCancelReplaceTypeEnum,
  OrderListOcoAboveTypeEnum: () => OrderListOcoAboveTypeEnum,
  OrderListOcoBelowTimeInForceEnum: () => OrderListOcoBelowTimeInForceEnum,
  OrderListOcoBelowTypeEnum: () => OrderListOcoBelowTypeEnum,
  OrderListOcoNewOrderRespTypeEnum: () => OrderListOcoNewOrderRespTypeEnum,
  OrderListOcoSelfTradePreventionModeEnum: () => OrderListOcoSelfTradePreventionModeEnum,
  OrderListOcoSideEnum: () => OrderListOcoSideEnum,
  OrderListOtoNewOrderRespTypeEnum: () => OrderListOtoNewOrderRespTypeEnum,
  OrderListOtoPendingSideEnum: () => OrderListOtoPendingSideEnum,
  OrderListOtoPendingTimeInForceEnum: () => OrderListOtoPendingTimeInForceEnum,
  OrderListOtoPendingTypeEnum: () => OrderListOtoPendingTypeEnum,
  OrderListOtoSelfTradePreventionModeEnum: () => OrderListOtoSelfTradePreventionModeEnum,
  OrderListOtoWorkingSideEnum: () => OrderListOtoWorkingSideEnum,
  OrderListOtoWorkingTimeInForceEnum: () => OrderListOtoWorkingTimeInForceEnum,
  OrderListOtoWorkingTypeEnum: () => OrderListOtoWorkingTypeEnum,
  OrderListOtocoNewOrderRespTypeEnum: () => OrderListOtocoNewOrderRespTypeEnum,
  OrderListOtocoPendingAboveTimeInForceEnum: () => OrderListOtocoPendingAboveTimeInForceEnum,
  OrderListOtocoPendingAboveTypeEnum: () => OrderListOtocoPendingAboveTypeEnum,
  OrderListOtocoPendingBelowTimeInForceEnum: () => OrderListOtocoPendingBelowTimeInForceEnum,
  OrderListOtocoPendingBelowTypeEnum: () => OrderListOtocoPendingBelowTypeEnum,
  OrderListOtocoPendingSideEnum: () => OrderListOtocoPendingSideEnum,
  OrderListOtocoSelfTradePreventionModeEnum: () => OrderListOtocoSelfTradePreventionModeEnum,
  OrderListOtocoWorkingSideEnum: () => OrderListOtocoWorkingSideEnum,
  OrderListOtocoWorkingTimeInForceEnum: () => OrderListOtocoWorkingTimeInForceEnum,
  OrderListOtocoWorkingTypeEnum: () => OrderListOtocoWorkingTypeEnum,
  OrderOcoNewOrderRespTypeEnum: () => OrderOcoNewOrderRespTypeEnum,
  OrderOcoSelfTradePreventionModeEnum: () => OrderOcoSelfTradePreventionModeEnum,
  OrderOcoSideEnum: () => OrderOcoSideEnum,
  OrderOcoStopLimitTimeInForceEnum: () => OrderOcoStopLimitTimeInForceEnum,
  RestAPI: () => RestAPI,
  SorOrderNewOrderRespTypeEnum: () => SorOrderNewOrderRespTypeEnum,
  SorOrderSelfTradePreventionModeEnum: () => SorOrderSelfTradePreventionModeEnum,
  SorOrderSideEnum: () => SorOrderSideEnum,
  SorOrderTimeInForceEnum: () => SorOrderTimeInForceEnum,
  SorOrderTypeEnum: () => SorOrderTypeEnum,
  Ticker24hrTypeEnum: () => Ticker24hrTypeEnum,
  TickerTradingDayTypeEnum: () => TickerTradingDayTypeEnum,
  TickerTypeEnum: () => TickerTypeEnum,
  TickerWindowSizeEnum: () => TickerWindowSizeEnum,
  TradeApi: () => TradeApi,
  UiKlinesIntervalEnum: () => UiKlinesIntervalEnum,
  UserdatastreamApi: () => UserdatastreamApi
});

// src/rest-api/modules/account-api.ts
var import_common = require("@binance/common");
var AccountApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Get current account commission rates.
     * Weight: 20
     *
     * @summary Query Commission Rates
     * @param {string} symbol
     *
     * @throws {RequiredError}
     */
    accountCommission: async (symbol) => {
      (0, import_common.assertParamExists)("accountCommission", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/account/commission",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Get current account information.
     * Weight: 20
     *
     * @summary Account information
     * @param {boolean} [omitZeroBalances] When set to `true`, emits only the non-zero balances of an account. <br>Default value: `false`
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    getAccount: async (omitZeroBalances, recvWindow) => {
      const localVarQueryParameter = {};
      if (omitZeroBalances !== void 0 && omitZeroBalances !== null) {
        localVarQueryParameter["omitZeroBalances"] = omitZeroBalances;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/account",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Retrieves allocations resulting from SOR order placement.
     * Weight: 20
     *
     * @summary Query Allocations
     * @param {string} symbol
     * @param {number} [startTime]
     * @param {number} [endTime]
     * @param {number} [fromAllocationId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [orderId] This can only be used in combination with `symbol`.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    myAllocations: async (symbol, startTime, endTime, fromAllocationId, limit, orderId, recvWindow) => {
      (0, import_common.assertParamExists)("myAllocations", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (startTime !== void 0 && startTime !== null) {
        localVarQueryParameter["startTime"] = startTime;
      }
      if (endTime !== void 0 && endTime !== null) {
        localVarQueryParameter["endTime"] = endTime;
      }
      if (fromAllocationId !== void 0 && fromAllocationId !== null) {
        localVarQueryParameter["fromAllocationId"] = fromAllocationId;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      if (orderId !== void 0 && orderId !== null) {
        localVarQueryParameter["orderId"] = orderId;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/myAllocations",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Displays the list of orders that were expired due to STP.
     *
     * These are the combinations supported:
     *
     * `symbol` + `preventedMatchId`
     * `symbol` + `orderId`
     * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
     * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
     * Weight: Case                            | Weight
     * ----                            | -----
     * If `symbol` is invalid          | 2
     * Querying by `preventedMatchId`  | 2
     * Querying by `orderId`           | 20
     *
     * @summary Query Prevented Matches
     * @param {string} symbol
     * @param {number} [preventedMatchId]
     * @param {number} [orderId] This can only be used in combination with `symbol`.
     * @param {number} [fromPreventedMatchId]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    myPreventedMatches: async (symbol, preventedMatchId, orderId, fromPreventedMatchId, limit, recvWindow) => {
      (0, import_common.assertParamExists)("myPreventedMatches", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (preventedMatchId !== void 0 && preventedMatchId !== null) {
        localVarQueryParameter["preventedMatchId"] = preventedMatchId;
      }
      if (orderId !== void 0 && orderId !== null) {
        localVarQueryParameter["orderId"] = orderId;
      }
      if (fromPreventedMatchId !== void 0 && fromPreventedMatchId !== null) {
        localVarQueryParameter["fromPreventedMatchId"] = fromPreventedMatchId;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/myPreventedMatches",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Get trades for a specific account and symbol.
     * Weight: 20
     *
     * @summary Account trade list
     * @param {string} symbol
     * @param {number} [orderId] This can only be used in combination with `symbol`.
     * @param {number} [startTime]
     * @param {number} [endTime]
     * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    myTrades: async (symbol, orderId, startTime, endTime, fromId, limit, recvWindow) => {
      (0, import_common.assertParamExists)("myTrades", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (orderId !== void 0 && orderId !== null) {
        localVarQueryParameter["orderId"] = orderId;
      }
      if (startTime !== void 0 && startTime !== null) {
        localVarQueryParameter["startTime"] = startTime;
      }
      if (endTime !== void 0 && endTime !== null) {
        localVarQueryParameter["endTime"] = endTime;
      }
      if (fromId !== void 0 && fromId !== null) {
        localVarQueryParameter["fromId"] = fromId;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/myTrades",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Displays the user's unfilled order count for all intervals.
     * Weight: 40
     *
     * @summary Query Unfilled Order Count
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    rateLimitOrder: async (recvWindow) => {
      const localVarQueryParameter = {};
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/rateLimit/order",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    }
  };
};
var AccountApi = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
  }
  /**
   * Get current account commission rates.
   * Weight: 20
   *
   * @summary Query Commission Rates
   * @param {AccountCommissionRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AccountCommissionResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-commission-rates-user_data Binance API Documentation}
   */
  async accountCommission(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.accountCommission(
      requestParameters?.symbol
    );
    return (0, import_common.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Get current account information.
   * Weight: 20
   *
   * @summary Account information
   * @param {GetAccountRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetAccountResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-information-user_data Binance API Documentation}
   */
  async getAccount(requestParameters = {}) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getAccount(
      requestParameters?.omitZeroBalances,
      requestParameters?.recvWindow
    );
    return (0, import_common.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Retrieves allocations resulting from SOR order placement.
   * Weight: 20
   *
   * @summary Query Allocations
   * @param {MyAllocationsRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<MyAllocationsResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-allocations-user_data Binance API Documentation}
   */
  async myAllocations(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.myAllocations(
      requestParameters?.symbol,
      requestParameters?.startTime,
      requestParameters?.endTime,
      requestParameters?.fromAllocationId,
      requestParameters?.limit,
      requestParameters?.orderId,
      requestParameters?.recvWindow
    );
    return (0, import_common.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Displays the list of orders that were expired due to STP.
   *
   * These are the combinations supported:
   *
   * `symbol` + `preventedMatchId`
   * `symbol` + `orderId`
   * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
   * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
   * Weight: Case                            | Weight
   * ----                            | -----
   * If `symbol` is invalid          | 2
   * Querying by `preventedMatchId`  | 2
   * Querying by `orderId`           | 20
   *
   * @summary Query Prevented Matches
   * @param {MyPreventedMatchesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<MyPreventedMatchesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-prevented-matches-user_data Binance API Documentation}
   */
  async myPreventedMatches(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.myPreventedMatches(
      requestParameters?.symbol,
      requestParameters?.preventedMatchId,
      requestParameters?.orderId,
      requestParameters?.fromPreventedMatchId,
      requestParameters?.limit,
      requestParameters?.recvWindow
    );
    return (0, import_common.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Get trades for a specific account and symbol.
   * Weight: 20
   *
   * @summary Account trade list
   * @param {MyTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<MyTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-trade-list-user_data Binance API Documentation}
   */
  async myTrades(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.myTrades(
      requestParameters?.symbol,
      requestParameters?.orderId,
      requestParameters?.startTime,
      requestParameters?.endTime,
      requestParameters?.fromId,
      requestParameters?.limit,
      requestParameters?.recvWindow
    );
    return (0, import_common.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Displays the user's unfilled order count for all intervals.
   * Weight: 40
   *
   * @summary Query Unfilled Order Count
   * @param {RateLimitOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<RateLimitOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-unfilled-order-count-user_data Binance API Documentation}
   */
  async rateLimitOrder(requestParameters = {}) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.rateLimitOrder(
      requestParameters?.recvWindow
    );
    return (0, import_common.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
};

// src/rest-api/modules/general-api.ts
var import_common2 = require("@binance/common");
var GeneralApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Current exchange trading rules and symbol information
     * Weight: 20
     *
     * @summary Exchange information
     * @param {string} symbol
     * @param {Array<string>} [symbols] List of symbols to query
     * @param {Array<string>} [permissions] Examples: curl -X GET "https://api.binance.com/api/v3/exchangeInfo?permissions=SPOT" <br/> or <br/> curl -X GET "https://api.binance.com/api/v3/exchangeInfo?permissions=%5B%22MARGIN%22%2C%22LEVERAGED%22%5D" <br/> or <br/> curl -g -X GET 'https://api.binance.com/api/v3/exchangeInfo?permissions=["MARGIN","LEVERAGED"]'
     * @param {boolean} [showPermissionSets] Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`
     * @param {ExchangeInfoSymbolStatusEnum} [symbolStatus]
     *
     * @throws {RequiredError}
     */
    exchangeInfo: async (symbol, symbols, permissions, showPermissionSets, symbolStatus) => {
      (0, import_common2.assertParamExists)("exchangeInfo", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (symbols) {
        localVarQueryParameter["symbols"] = symbols;
      }
      if (permissions) {
        localVarQueryParameter["permissions"] = permissions;
      }
      if (showPermissionSets !== void 0 && showPermissionSets !== null) {
        localVarQueryParameter["showPermissionSets"] = showPermissionSets;
      }
      if (symbolStatus !== void 0 && symbolStatus !== null) {
        localVarQueryParameter["symbolStatus"] = symbolStatus;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/exchangeInfo",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Test connectivity to the Rest API.
     * Weight: 1
     *
     * @summary Test connectivity
     *
     * @throws {RequiredError}
     */
    ping: async () => {
      const localVarQueryParameter = {};
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/ping",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Test connectivity to the Rest API and get the current server time.
     * Weight: 1
     *
     * @summary Check server time
     *
     * @throws {RequiredError}
     */
    time: async () => {
      const localVarQueryParameter = {};
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/time",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    }
  };
};
var GeneralApi = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration);
  }
  /**
   * Current exchange trading rules and symbol information
   * Weight: 20
   *
   * @summary Exchange information
   * @param {ExchangeInfoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<ExchangeInfoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof GeneralApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#exchange-information Binance API Documentation}
   */
  async exchangeInfo(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.exchangeInfo(
      requestParameters?.symbol,
      requestParameters?.symbols,
      requestParameters?.permissions,
      requestParameters?.showPermissionSets,
      requestParameters?.symbolStatus
    );
    return (0, import_common2.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Test connectivity to the Rest API.
   * Weight: 1
   *
   * @summary Test connectivity
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof GeneralApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#test-connectivity Binance API Documentation}
   */
  async ping() {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.ping();
    return (0, import_common2.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Test connectivity to the Rest API and get the current server time.
   * Weight: 1
   *
   * @summary Check server time
   * @returns {Promise<RestApiResponse<TimeResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof GeneralApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#check-server-time Binance API Documentation}
   */
  async time() {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.time();
    return (0, import_common2.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
};
var ExchangeInfoSymbolStatusEnum = {
  PRE_TRADING: "PRE_TRADING",
  TRADING: "TRADING",
  POST_TRADING: "POST_TRADING",
  END_OF_DAY: "END_OF_DAY",
  HALT: "HALT",
  AUCTION_MATCH: "AUCTION_MATCH",
  BREAK: "BREAK"
};

// src/rest-api/modules/market-api.ts
var import_common3 = require("@binance/common");
var MarketApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
     * Weight: 4
     *
     * @summary Compressed/Aggregate trades list
     * @param {string} symbol
     * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
     * @param {number} [startTime]
     * @param {number} [endTime]
     * @param {number} [limit] Default 500; max 1000.
     *
     * @throws {RequiredError}
     */
    aggTrades: async (symbol, fromId, startTime, endTime, limit) => {
      (0, import_common3.assertParamExists)("aggTrades", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (fromId !== void 0 && fromId !== null) {
        localVarQueryParameter["fromId"] = fromId;
      }
      if (startTime !== void 0 && startTime !== null) {
        localVarQueryParameter["startTime"] = startTime;
      }
      if (endTime !== void 0 && endTime !== null) {
        localVarQueryParameter["endTime"] = endTime;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/aggTrades",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Current average price for a symbol.
     * Weight: 2
     *
     * @summary Current average price
     * @param {string} symbol
     *
     * @throws {RequiredError}
     */
    avgPrice: async (symbol) => {
      (0, import_common3.assertParamExists)("avgPrice", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/avgPrice",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     *
     * Weight: Adjusted based on the limit:
     *
     * |Limit|Request Weight
     * ------|-------
     * 1-100|  5
     * 101-500| 25
     * 501-1000| 50
     * 1001-5000| 250
     *
     * @summary Order book
     * @param {string} symbol
     * @param {number} [limit] Default 500; max 1000.
     *
     * @throws {RequiredError}
     */
    depth: async (symbol, limit) => {
      (0, import_common3.assertParamExists)("depth", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/depth",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Get recent trades.
     * Weight: 25
     *
     * @summary Recent trades list
     * @param {string} symbol
     * @param {number} [limit] Default 500; max 1000.
     *
     * @throws {RequiredError}
     */
    getTrades: async (symbol, limit) => {
      (0, import_common3.assertParamExists)("getTrades", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/trades",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Get older trades.
     * Weight: 25
     *
     * @summary Old trade lookup
     * @param {string} symbol
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
     *
     * @throws {RequiredError}
     */
    historicalTrades: async (symbol, limit, fromId) => {
      (0, import_common3.assertParamExists)("historicalTrades", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      if (fromId !== void 0 && fromId !== null) {
        localVarQueryParameter["fromId"] = fromId;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/historicalTrades",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Kline/candlestick bars for a symbol.
     * Klines are uniquely identified by their open time.
     * Weight: 2
     *
     * @summary Kline/Candlestick data
     * @param {string} symbol
     * @param {KlinesIntervalEnum} [interval]
     * @param {number} [startTime]
     * @param {number} [endTime]
     * @param {string} [timeZone] Default: 0 (UTC)
     * @param {number} [limit] Default 500; max 1000.
     *
     * @throws {RequiredError}
     */
    klines: async (symbol, interval, startTime, endTime, timeZone, limit) => {
      (0, import_common3.assertParamExists)("klines", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (interval !== void 0 && interval !== null) {
        localVarQueryParameter["interval"] = interval;
      }
      if (startTime !== void 0 && startTime !== null) {
        localVarQueryParameter["startTime"] = startTime;
      }
      if (endTime !== void 0 && endTime !== null) {
        localVarQueryParameter["endTime"] = endTime;
      }
      if (timeZone !== void 0 && timeZone !== null) {
        localVarQueryParameter["timeZone"] = timeZone;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/klines",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     *
     * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Rolling window price change statistics
     * @param {string} symbol
     * @param {Array<string>} [symbols] List of symbols to query
     * @param {TickerWindowSizeEnum} [windowSize]
     * @param {TickerTypeEnum} [type]
     *
     * @throws {RequiredError}
     */
    ticker: async (symbol, symbols, windowSize, type) => {
      (0, import_common3.assertParamExists)("ticker", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (symbols) {
        localVarQueryParameter["symbols"] = symbols;
      }
      if (windowSize !== void 0 && windowSize !== null) {
        localVarQueryParameter["windowSize"] = windowSize;
      }
      if (type !== void 0 && type !== null) {
        localVarQueryParameter["type"] = type;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/ticker",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td rowspan="4">symbols</td>
     * <td>1-20</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>21-100</td>
     * <td>40</td>
     * </tr>
     * <tr>
     * <td>101 or more</td>
     * <td>80</td>
     * </tr>
     * <tr>
     * <td>symbols parameter is omitted</td>
     * <td>80</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary 24hr ticker price change statistics
     * @param {string} symbol
     * @param {Array<string>} [symbols] List of symbols to query
     * @param {Ticker24hrTypeEnum} [type]
     *
     * @throws {RequiredError}
     */
    ticker24hr: async (symbol, symbols, type) => {
      (0, import_common3.assertParamExists)("ticker24hr", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (symbols) {
        localVarQueryParameter["symbols"] = symbols;
      }
      if (type !== void 0 && type !== null) {
        localVarQueryParameter["type"] = type;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/ticker/24hr",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Best price/qty on the order book for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol order book ticker
     * @param {string} symbol
     * @param {Array<string>} [symbols] List of symbols to query
     *
     * @throws {RequiredError}
     */
    tickerBookTicker: async (symbol, symbols) => {
      (0, import_common3.assertParamExists)("tickerBookTicker", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (symbols) {
        localVarQueryParameter["symbols"] = symbols;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/ticker/bookTicker",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Latest price for a symbol or symbols.
     * Weight: <table>
     * <thead>
     * <tr>
     * <th>Parameter</th>
     * <th>Symbols Provided</th>
     * <th>Weight</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <td rowspan="2">symbol</td>
     * <td>1</td>
     * <td>2</td>
     * </tr>
     * <tr>
     * <td>symbol parameter is omitted</td>
     * <td>4</td>
     * </tr>
     * <tr>
     * <td>symbols</td>
     * <td>Any</td>
     * <td>4</td>
     * </tr>
     * </tbody>
     * </table>
     *
     * @summary Symbol price ticker
     * @param {string} symbol
     * @param {Array<string>} [symbols] List of symbols to query
     *
     * @throws {RequiredError}
     */
    tickerPrice: async (symbol, symbols) => {
      (0, import_common3.assertParamExists)("tickerPrice", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (symbols) {
        localVarQueryParameter["symbols"] = symbols;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/ticker/price",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Price change statistics for a trading day.
     * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
     *
     * @summary Trading Day Ticker
     * @param {string} symbol
     * @param {Array<string>} [symbols] List of symbols to query
     * @param {string} [timeZone] Default: 0 (UTC)
     * @param {TickerTradingDayTypeEnum} [type]
     *
     * @throws {RequiredError}
     */
    tickerTradingDay: async (symbol, symbols, timeZone, type) => {
      (0, import_common3.assertParamExists)("tickerTradingDay", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (symbols) {
        localVarQueryParameter["symbols"] = symbols;
      }
      if (timeZone !== void 0 && timeZone !== null) {
        localVarQueryParameter["timeZone"] = timeZone;
      }
      if (type !== void 0 && type !== null) {
        localVarQueryParameter["type"] = type;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/ticker/tradingDay",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * The request is similar to klines having the same parameters and response.
     *
     * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
     * Weight: 2
     *
     * @summary UIKlines
     * @param {string} symbol
     * @param {UiKlinesIntervalEnum} [interval]
     * @param {number} [startTime]
     * @param {number} [endTime]
     * @param {string} [timeZone] Default: 0 (UTC)
     * @param {number} [limit] Default 500; max 1000.
     *
     * @throws {RequiredError}
     */
    uiKlines: async (symbol, interval, startTime, endTime, timeZone, limit) => {
      (0, import_common3.assertParamExists)("uiKlines", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (interval !== void 0 && interval !== null) {
        localVarQueryParameter["interval"] = interval;
      }
      if (startTime !== void 0 && startTime !== null) {
        localVarQueryParameter["startTime"] = startTime;
      }
      if (endTime !== void 0 && endTime !== null) {
        localVarQueryParameter["endTime"] = endTime;
      }
      if (timeZone !== void 0 && timeZone !== null) {
        localVarQueryParameter["timeZone"] = timeZone;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/uiKlines",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    }
  };
};
var MarketApi = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.localVarAxiosParamCreator = MarketApiAxiosParamCreator(configuration);
  }
  /**
   * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
   * Weight: 4
   *
   * @summary Compressed/Aggregate trades list
   * @param {AggTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AggTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#compressedaggregate-trades-list Binance API Documentation}
   */
  async aggTrades(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.aggTrades(
      requestParameters?.symbol,
      requestParameters?.fromId,
      requestParameters?.startTime,
      requestParameters?.endTime,
      requestParameters?.limit
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Current average price for a symbol.
   * Weight: 2
   *
   * @summary Current average price
   * @param {AvgPriceRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AvgPriceResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#current-average-price Binance API Documentation}
   */
  async avgPrice(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.avgPrice(
      requestParameters?.symbol
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   *
   * Weight: Adjusted based on the limit:
   *
   * |Limit|Request Weight
   * ------|-------
   * 1-100|  5
   * 101-500| 25
   * 501-1000| 50
   * 1001-5000| 250
   *
   * @summary Order book
   * @param {DepthRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DepthResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#order-book Binance API Documentation}
   */
  async depth(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.depth(
      requestParameters?.symbol,
      requestParameters?.limit
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Get recent trades.
   * Weight: 25
   *
   * @summary Recent trades list
   * @param {GetTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#recent-trades-list Binance API Documentation}
   */
  async getTrades(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getTrades(
      requestParameters?.symbol,
      requestParameters?.limit
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Get older trades.
   * Weight: 25
   *
   * @summary Old trade lookup
   * @param {HistoricalTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<HistoricalTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#old-trade-lookup Binance API Documentation}
   */
  async historicalTrades(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.historicalTrades(
      requestParameters?.symbol,
      requestParameters?.limit,
      requestParameters?.fromId
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Kline/candlestick bars for a symbol.
   * Klines are uniquely identified by their open time.
   * Weight: 2
   *
   * @summary Kline/Candlestick data
   * @param {KlinesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<KlinesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#klinecandlestick-data Binance API Documentation}
   */
  async klines(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.klines(
      requestParameters?.symbol,
      requestParameters?.interval,
      requestParameters?.startTime,
      requestParameters?.endTime,
      requestParameters?.timeZone,
      requestParameters?.limit
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   *
   * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
   *
   * @summary Rolling window price change statistics
   * @param {TickerRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#rolling-window-price-change-statistics Binance API Documentation}
   */
  async ticker(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.ticker(
      requestParameters?.symbol,
      requestParameters?.symbols,
      requestParameters?.windowSize,
      requestParameters?.type
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
   * Weight: <table>
   * <thead>
   * <tr>
   * <th>Parameter</th>
   * <th>Symbols Provided</th>
   * <th>Weight</th>
   * </tr>
   * </thead>
   * <tbody>
   * <tr>
   * <td rowspan="2">symbol</td>
   * <td>1</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>symbol parameter is omitted</td>
   * <td>80</td>
   * </tr>
   * <tr>
   * <td rowspan="4">symbols</td>
   * <td>1-20</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>21-100</td>
   * <td>40</td>
   * </tr>
   * <tr>
   * <td>101 or more</td>
   * <td>80</td>
   * </tr>
   * <tr>
   * <td>symbols parameter is omitted</td>
   * <td>80</td>
   * </tr>
   * </tbody>
   * </table>
   *
   * @summary 24hr ticker price change statistics
   * @param {Ticker24hrRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<Ticker24hrResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics Binance API Documentation}
   */
  async ticker24hr(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.ticker24hr(
      requestParameters?.symbol,
      requestParameters?.symbols,
      requestParameters?.type
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Best price/qty on the order book for a symbol or symbols.
   * Weight: <table>
   * <thead>
   * <tr>
   * <th>Parameter</th>
   * <th>Symbols Provided</th>
   * <th>Weight</th>
   * </tr>
   * </thead>
   * <tbody>
   * <tr>
   * <td rowspan="2">symbol</td>
   * <td>1</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>symbol parameter is omitted</td>
   * <td>4</td>
   * </tr>
   * <tr>
   * <td>symbols</td>
   * <td>Any</td>
   * <td>4</td>
   * </tr>
   * </tbody>
   * </table>
   *
   * @summary Symbol order book ticker
   * @param {TickerBookTickerRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerBookTickerResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-order-book-ticker Binance API Documentation}
   */
  async tickerBookTicker(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerBookTicker(
      requestParameters?.symbol,
      requestParameters?.symbols
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Latest price for a symbol or symbols.
   * Weight: <table>
   * <thead>
   * <tr>
   * <th>Parameter</th>
   * <th>Symbols Provided</th>
   * <th>Weight</th>
   * </tr>
   * </thead>
   * <tbody>
   * <tr>
   * <td rowspan="2">symbol</td>
   * <td>1</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>symbol parameter is omitted</td>
   * <td>4</td>
   * </tr>
   * <tr>
   * <td>symbols</td>
   * <td>Any</td>
   * <td>4</td>
   * </tr>
   * </tbody>
   * </table>
   *
   * @summary Symbol price ticker
   * @param {TickerPriceRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerPriceResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-price-ticker Binance API Documentation}
   */
  async tickerPrice(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerPrice(
      requestParameters?.symbol,
      requestParameters?.symbols
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Price change statistics for a trading day.
   * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
   *
   * @summary Trading Day Ticker
   * @param {TickerTradingDayRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerTradingDayResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#trading-day-ticker Binance API Documentation}
   */
  async tickerTradingDay(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.tickerTradingDay(
      requestParameters?.symbol,
      requestParameters?.symbols,
      requestParameters?.timeZone,
      requestParameters?.type
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * The request is similar to klines having the same parameters and response.
   *
   * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
   * Weight: 2
   *
   * @summary UIKlines
   * @param {UiKlinesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<UiKlinesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#uiklines Binance API Documentation}
   */
  async uiKlines(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.uiKlines(
      requestParameters?.symbol,
      requestParameters?.interval,
      requestParameters?.startTime,
      requestParameters?.endTime,
      requestParameters?.timeZone,
      requestParameters?.limit
    );
    return (0, import_common3.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
};
var KlinesIntervalEnum = {
  INTERVAL_1s: "1s",
  INTERVAL_1m: "1m",
  INTERVAL_3m: "3m",
  INTERVAL_5m: "5m",
  INTERVAL_15m: "15m",
  INTERVAL_30m: "30m",
  INTERVAL_1h: "1h",
  INTERVAL_2h: "2h",
  INTERVAL_4h: "4h",
  INTERVAL_6h: "6h",
  INTERVAL_8h: "8h",
  INTERVAL_12h: "12h",
  INTERVAL_1d: "1d",
  INTERVAL_3d: "3d",
  INTERVAL_1w: "1w",
  INTERVAL_1M: "1M"
};
var TickerWindowSizeEnum = {
  WINDOW_SIZE_1m: "1m",
  WINDOW_SIZE_2m: "2m",
  WINDOW_SIZE_3m: "3m",
  WINDOW_SIZE_4m: "4m",
  WINDOW_SIZE_5m: "5m",
  WINDOW_SIZE_6m: "6m",
  WINDOW_SIZE_7m: "7m",
  WINDOW_SIZE_8m: "8m",
  WINDOW_SIZE_9m: "9m",
  WINDOW_SIZE_10m: "10m",
  WINDOW_SIZE_11m: "11m",
  WINDOW_SIZE_12m: "12m",
  WINDOW_SIZE_13m: "13m",
  WINDOW_SIZE_14m: "14m",
  WINDOW_SIZE_15m: "15m",
  WINDOW_SIZE_16m: "16m",
  WINDOW_SIZE_17m: "17m",
  WINDOW_SIZE_18m: "18m",
  WINDOW_SIZE_19m: "19m",
  WINDOW_SIZE_20m: "20m",
  WINDOW_SIZE_21m: "21m",
  WINDOW_SIZE_22m: "22m",
  WINDOW_SIZE_23m: "23m",
  WINDOW_SIZE_24m: "24m",
  WINDOW_SIZE_25m: "25m",
  WINDOW_SIZE_26m: "26m",
  WINDOW_SIZE_27m: "27m",
  WINDOW_SIZE_28m: "28m",
  WINDOW_SIZE_29m: "29m",
  WINDOW_SIZE_30m: "30m",
  WINDOW_SIZE_31m: "31m",
  WINDOW_SIZE_32m: "32m",
  WINDOW_SIZE_33m: "33m",
  WINDOW_SIZE_34m: "34m",
  WINDOW_SIZE_35m: "35m",
  WINDOW_SIZE_36m: "36m",
  WINDOW_SIZE_37m: "37m",
  WINDOW_SIZE_38m: "38m",
  WINDOW_SIZE_39m: "39m",
  WINDOW_SIZE_40m: "40m",
  WINDOW_SIZE_41m: "41m",
  WINDOW_SIZE_42m: "42m",
  WINDOW_SIZE_43m: "43m",
  WINDOW_SIZE_44m: "44m",
  WINDOW_SIZE_45m: "45m",
  WINDOW_SIZE_46m: "46m",
  WINDOW_SIZE_47m: "47m",
  WINDOW_SIZE_48m: "48m",
  WINDOW_SIZE_49m: "49m",
  WINDOW_SIZE_50m: "50m",
  WINDOW_SIZE_51m: "51m",
  WINDOW_SIZE_52m: "52m",
  WINDOW_SIZE_53m: "53m",
  WINDOW_SIZE_54m: "54m",
  WINDOW_SIZE_55m: "55m",
  WINDOW_SIZE_56m: "56m",
  WINDOW_SIZE_57m: "57m",
  WINDOW_SIZE_58m: "58m",
  WINDOW_SIZE_59m: "59m",
  WINDOW_SIZE_1h: "1h",
  WINDOW_SIZE_2h: "2h",
  WINDOW_SIZE_3h: "3h",
  WINDOW_SIZE_4h: "4h",
  WINDOW_SIZE_5h: "5h",
  WINDOW_SIZE_6h: "6h",
  WINDOW_SIZE_7h: "7h",
  WINDOW_SIZE_8h: "8h",
  WINDOW_SIZE_9h: "9h",
  WINDOW_SIZE_10h: "10h",
  WINDOW_SIZE_11h: "11h",
  WINDOW_SIZE_12h: "12h",
  WINDOW_SIZE_13h: "13h",
  WINDOW_SIZE_14h: "14h",
  WINDOW_SIZE_15h: "15h",
  WINDOW_SIZE_16h: "16h",
  WINDOW_SIZE_17h: "17h",
  WINDOW_SIZE_18h: "18h",
  WINDOW_SIZE_19h: "19h",
  WINDOW_SIZE_20h: "20h",
  WINDOW_SIZE_21h: "21h",
  WINDOW_SIZE_22h: "22h",
  WINDOW_SIZE_23h: "23h",
  WINDOW_SIZE_1d: "1d",
  WINDOW_SIZE_2d: "2d",
  WINDOW_SIZE_3d: "3d",
  WINDOW_SIZE_4d: "4d",
  WINDOW_SIZE_5d: "5d",
  WINDOW_SIZE_6d: "6d"
};
var TickerTypeEnum = {
  FULL: "FULL",
  MINI: "MINI"
};
var Ticker24hrTypeEnum = {
  FULL: "FULL",
  MINI: "MINI"
};
var TickerTradingDayTypeEnum = {
  FULL: "FULL",
  MINI: "MINI"
};
var UiKlinesIntervalEnum = {
  INTERVAL_1s: "1s",
  INTERVAL_1m: "1m",
  INTERVAL_3m: "3m",
  INTERVAL_5m: "5m",
  INTERVAL_15m: "15m",
  INTERVAL_30m: "30m",
  INTERVAL_1h: "1h",
  INTERVAL_2h: "2h",
  INTERVAL_4h: "4h",
  INTERVAL_6h: "6h",
  INTERVAL_8h: "8h",
  INTERVAL_12h: "12h",
  INTERVAL_1d: "1d",
  INTERVAL_3d: "3d",
  INTERVAL_1w: "1w",
  INTERVAL_1M: "1M"
};

// src/rest-api/modules/trade-api.ts
var import_common4 = require("@binance/common");
var TradeApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Retrieves all order lists based on provided optional parameters.
     *
     * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
     * Weight: 20
     *
     * @summary Query all Order lists
     * @param {number} [fromId] TradeId to fetch from. Default gets most recent trades.
     * @param {number} [startTime]
     * @param {number} [endTime]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    allOrderList: async (fromId, startTime, endTime, limit, recvWindow) => {
      const localVarQueryParameter = {};
      if (fromId !== void 0 && fromId !== null) {
        localVarQueryParameter["fromId"] = fromId;
      }
      if (startTime !== void 0 && startTime !== null) {
        localVarQueryParameter["startTime"] = startTime;
      }
      if (endTime !== void 0 && endTime !== null) {
        localVarQueryParameter["endTime"] = endTime;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/allOrderList",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Get all account orders; active, canceled, or filled.
     * Weight: 20
     *
     * @summary All orders
     * @param {string} symbol
     * @param {number} [orderId] This can only be used in combination with `symbol`.
     * @param {number} [startTime]
     * @param {number} [endTime]
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    allOrders: async (symbol, orderId, startTime, endTime, limit, recvWindow) => {
      (0, import_common4.assertParamExists)("allOrders", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (orderId !== void 0 && orderId !== null) {
        localVarQueryParameter["orderId"] = orderId;
      }
      if (startTime !== void 0 && startTime !== null) {
        localVarQueryParameter["startTime"] = startTime;
      }
      if (endTime !== void 0 && endTime !== null) {
        localVarQueryParameter["endTime"] = endTime;
      }
      if (limit !== void 0 && limit !== null) {
        localVarQueryParameter["limit"] = limit;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/allOrders",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Cancels all active orders on a symbol.
     * This includes orders that are part of an order list.
     * Weight: 1
     *
     * @summary Cancel All Open Orders on a Symbol
     * @param {string} symbol
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    deleteOpenOrders: async (symbol, recvWindow) => {
      (0, import_common4.assertParamExists)("deleteOpenOrders", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/openOrders",
        method: "DELETE",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Cancel an active order.
     * Weight: 1
     *
     * @summary Cancel order
     * @param {string} symbol
     * @param {number} [orderId] This can only be used in combination with `symbol`.
     * @param {string} [origClientOrderId] Either ```orderListId``` or ```listClientOrderId``` must be provided
     * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @param {DeleteOrderCancelRestrictionsEnum} [cancelRestrictions]
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    deleteOrder: async (symbol, orderId, origClientOrderId, newClientOrderId, cancelRestrictions, recvWindow) => {
      (0, import_common4.assertParamExists)("deleteOrder", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (orderId !== void 0 && orderId !== null) {
        localVarQueryParameter["orderId"] = orderId;
      }
      if (origClientOrderId !== void 0 && origClientOrderId !== null) {
        localVarQueryParameter["origClientOrderId"] = origClientOrderId;
      }
      if (newClientOrderId !== void 0 && newClientOrderId !== null) {
        localVarQueryParameter["newClientOrderId"] = newClientOrderId;
      }
      if (cancelRestrictions !== void 0 && cancelRestrictions !== null) {
        localVarQueryParameter["cancelRestrictions"] = cancelRestrictions;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/order",
        method: "DELETE",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Cancel an entire Order list
     * Weight: 1
     *
     * @summary Cancel Order list
     * @param {string} symbol
     * @param {number} [orderListId] Either```orderListId```or```listClientOrderId```mustbeprovided
     * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    deleteOrderList: async (symbol, orderListId, listClientOrderId, newClientOrderId, recvWindow) => {
      (0, import_common4.assertParamExists)("deleteOrderList", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (orderListId !== void 0 && orderListId !== null) {
        localVarQueryParameter["orderListId"] = orderListId;
      }
      if (listClientOrderId !== void 0 && listClientOrderId !== null) {
        localVarQueryParameter["listClientOrderId"] = listClientOrderId;
      }
      if (newClientOrderId !== void 0 && newClientOrderId !== null) {
        localVarQueryParameter["newClientOrderId"] = newClientOrderId;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/orderList",
        method: "DELETE",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
     * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
     *
     * @summary Current open orders
     * @param {string} symbol
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    getOpenOrders: async (symbol, recvWindow) => {
      (0, import_common4.assertParamExists)("getOpenOrders", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/openOrders",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Check an order's status.
     * Weight: 4
     *
     * @summary Query order
     * @param {string} symbol
     * @param {number} [orderId] This can only be used in combination with `symbol`.
     * @param {string} [origClientOrderId] Either ```orderListId``` or ```listClientOrderId``` must be provided
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    getOrder: async (symbol, orderId, origClientOrderId, recvWindow) => {
      (0, import_common4.assertParamExists)("getOrder", "symbol", symbol);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (orderId !== void 0 && orderId !== null) {
        localVarQueryParameter["orderId"] = orderId;
      }
      if (origClientOrderId !== void 0 && origClientOrderId !== null) {
        localVarQueryParameter["origClientOrderId"] = origClientOrderId;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/order",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Retrieves a specific order list based on provided optional parameters.
     * Weight: 4
     *
     * @summary Query Order list
     * @param {number} [orderListId] Either```orderListId```or```listClientOrderId```mustbeprovided
     * @param {string} [origClientOrderId] Either ```orderListId``` or ```listClientOrderId``` must be provided
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    getOrderList: async (orderListId, origClientOrderId, recvWindow) => {
      const localVarQueryParameter = {};
      if (orderListId !== void 0 && orderListId !== null) {
        localVarQueryParameter["orderListId"] = orderListId;
      }
      if (origClientOrderId !== void 0 && origClientOrderId !== null) {
        localVarQueryParameter["origClientOrderId"] = origClientOrderId;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/orderList",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Send in a new order.
     * Weight: 1
     *
     * @summary New order
     * @param {string} symbol
     * @param {number} quantity
     * @param {number} stopPrice
     * @param {NewOrderSideEnum} [side]
     * @param {NewOrderTypeEnum} [type]
     * @param {NewOrderTimeInForceEnum} [timeInForce]
     * @param {number} [quoteOrderQty]
     * @param {number} [price]
     * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than `1000000`.
     * @param {number} [trailingDelta]
     * @param {number} [icebergQty] Used with `LIMIT` to create an iceberg order.
     * @param {NewOrderNewOrderRespTypeEnum} [newOrderRespType]
     * @param {NewOrderSelfTradePreventionModeEnum} [selfTradePreventionMode]
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    newOrder: async (symbol, quantity, stopPrice, side, type, timeInForce, quoteOrderQty, price, newClientOrderId, strategyId, strategyType, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow) => {
      (0, import_common4.assertParamExists)("newOrder", "symbol", symbol);
      (0, import_common4.assertParamExists)("newOrder", "quantity", quantity);
      (0, import_common4.assertParamExists)("newOrder", "stopPrice", stopPrice);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (side !== void 0 && side !== null) {
        localVarQueryParameter["side"] = side;
      }
      if (type !== void 0 && type !== null) {
        localVarQueryParameter["type"] = type;
      }
      if (timeInForce !== void 0 && timeInForce !== null) {
        localVarQueryParameter["timeInForce"] = timeInForce;
      }
      if (quantity !== void 0 && quantity !== null) {
        localVarQueryParameter["quantity"] = quantity;
      }
      if (quoteOrderQty !== void 0 && quoteOrderQty !== null) {
        localVarQueryParameter["quoteOrderQty"] = quoteOrderQty;
      }
      if (price !== void 0 && price !== null) {
        localVarQueryParameter["price"] = price;
      }
      if (newClientOrderId !== void 0 && newClientOrderId !== null) {
        localVarQueryParameter["newClientOrderId"] = newClientOrderId;
      }
      if (strategyId !== void 0 && strategyId !== null) {
        localVarQueryParameter["strategyId"] = strategyId;
      }
      if (strategyType !== void 0 && strategyType !== null) {
        localVarQueryParameter["strategyType"] = strategyType;
      }
      if (stopPrice !== void 0 && stopPrice !== null) {
        localVarQueryParameter["stopPrice"] = stopPrice;
      }
      if (trailingDelta !== void 0 && trailingDelta !== null) {
        localVarQueryParameter["trailingDelta"] = trailingDelta;
      }
      if (icebergQty !== void 0 && icebergQty !== null) {
        localVarQueryParameter["icebergQty"] = icebergQty;
      }
      if (newOrderRespType !== void 0 && newOrderRespType !== null) {
        localVarQueryParameter["newOrderRespType"] = newOrderRespType;
      }
      if (selfTradePreventionMode !== void 0 && selfTradePreventionMode !== null) {
        localVarQueryParameter["selfTradePreventionMode"] = selfTradePreventionMode;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/order",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     *
     * Weight: 6
     *
     * @summary Query Open Order lists
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    openOrderList: async (recvWindow) => {
      const localVarQueryParameter = {};
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/openOrderList",
        method: "GET",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Cancels an existing order and places a new order on the same symbol.
     *
     * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
     *
     * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED` ), will still increase the order count by 1.
     * Weight: 1
     *
     * @summary Cancel an Existing Order and Send a New Order
     * @param {string} symbol
     * @param {number} quantity
     * @param {number} stopPrice
     * @param {OrderCancelReplaceSideEnum} [side]
     * @param {OrderCancelReplaceTypeEnum} [type]
     * @param {OrderCancelReplaceCancelReplaceModeEnum} [cancelReplaceMode]
     * @param {OrderCancelReplaceTimeInForceEnum} [timeInForce]
     * @param {number} [quoteOrderQty]
     * @param {number} [price]
     * @param {string} [cancelNewClientOrderId] Used to uniquely identify this cancel. Automatically generated by default.
     * @param {string} [cancelOrigClientOrderId] Either the `cancelOrigClientOrderId` or `cancelOrderId` must be provided. If both are provided, `cancelOrderId` takes precedence.
     * @param {number} [cancelOrderId] Either the `cancelOrigClientOrderId` or `cancelOrderId` must be provided. If both are provided, `cancelOrderId` takes precedence.
     * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than `1000000`.
     * @param {number} [trailingDelta]
     * @param {number} [icebergQty] Used with `LIMIT` to create an iceberg order.
     * @param {OrderCancelReplaceNewOrderRespTypeEnum} [newOrderRespType]
     * @param {OrderCancelReplaceSelfTradePreventionModeEnum} [selfTradePreventionMode]
     * @param {OrderCancelReplaceCancelRestrictionsEnum} [cancelRestrictions]
     * @param {OrderCancelReplaceOrderRateLimitExceededModeEnum} [orderRateLimitExceededMode]
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    orderCancelReplace: async (symbol, quantity, stopPrice, side, type, cancelReplaceMode, timeInForce, quoteOrderQty, price, cancelNewClientOrderId, cancelOrigClientOrderId, cancelOrderId, newClientOrderId, strategyId, strategyType, trailingDelta, icebergQty, newOrderRespType, selfTradePreventionMode, cancelRestrictions, orderRateLimitExceededMode, recvWindow) => {
      (0, import_common4.assertParamExists)("orderCancelReplace", "symbol", symbol);
      (0, import_common4.assertParamExists)("orderCancelReplace", "quantity", quantity);
      (0, import_common4.assertParamExists)("orderCancelReplace", "stopPrice", stopPrice);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (side !== void 0 && side !== null) {
        localVarQueryParameter["side"] = side;
      }
      if (type !== void 0 && type !== null) {
        localVarQueryParameter["type"] = type;
      }
      if (cancelReplaceMode !== void 0 && cancelReplaceMode !== null) {
        localVarQueryParameter["cancelReplaceMode"] = cancelReplaceMode;
      }
      if (timeInForce !== void 0 && timeInForce !== null) {
        localVarQueryParameter["timeInForce"] = timeInForce;
      }
      if (quantity !== void 0 && quantity !== null) {
        localVarQueryParameter["quantity"] = quantity;
      }
      if (quoteOrderQty !== void 0 && quoteOrderQty !== null) {
        localVarQueryParameter["quoteOrderQty"] = quoteOrderQty;
      }
      if (price !== void 0 && price !== null) {
        localVarQueryParameter["price"] = price;
      }
      if (cancelNewClientOrderId !== void 0 && cancelNewClientOrderId !== null) {
        localVarQueryParameter["cancelNewClientOrderId"] = cancelNewClientOrderId;
      }
      if (cancelOrigClientOrderId !== void 0 && cancelOrigClientOrderId !== null) {
        localVarQueryParameter["cancelOrigClientOrderId"] = cancelOrigClientOrderId;
      }
      if (cancelOrderId !== void 0 && cancelOrderId !== null) {
        localVarQueryParameter["cancelOrderId"] = cancelOrderId;
      }
      if (newClientOrderId !== void 0 && newClientOrderId !== null) {
        localVarQueryParameter["newClientOrderId"] = newClientOrderId;
      }
      if (strategyId !== void 0 && strategyId !== null) {
        localVarQueryParameter["strategyId"] = strategyId;
      }
      if (strategyType !== void 0 && strategyType !== null) {
        localVarQueryParameter["strategyType"] = strategyType;
      }
      if (stopPrice !== void 0 && stopPrice !== null) {
        localVarQueryParameter["stopPrice"] = stopPrice;
      }
      if (trailingDelta !== void 0 && trailingDelta !== null) {
        localVarQueryParameter["trailingDelta"] = trailingDelta;
      }
      if (icebergQty !== void 0 && icebergQty !== null) {
        localVarQueryParameter["icebergQty"] = icebergQty;
      }
      if (newOrderRespType !== void 0 && newOrderRespType !== null) {
        localVarQueryParameter["newOrderRespType"] = newOrderRespType;
      }
      if (selfTradePreventionMode !== void 0 && selfTradePreventionMode !== null) {
        localVarQueryParameter["selfTradePreventionMode"] = selfTradePreventionMode;
      }
      if (cancelRestrictions !== void 0 && cancelRestrictions !== null) {
        localVarQueryParameter["cancelRestrictions"] = cancelRestrictions;
      }
      if (orderRateLimitExceededMode !== void 0 && orderRateLimitExceededMode !== null) {
        localVarQueryParameter["orderRateLimitExceededMode"] = orderRateLimitExceededMode;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/order/cancelReplace",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
     *
     * An OCO has 2 orders called the **above order** and **below order**.
     * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
     * Price restrictions
     * If the OCO is on the `SELL` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
     * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * If the OCO is on the `BUY` side:
     * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
     * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
     * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OCO
     * @param {string} symbol
     * @param {number} quantity
     * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @param {OrderListOcoSideEnum} [side]
     * @param {OrderListOcoAboveTypeEnum} [aboveType]
     * @param {string} [aboveClientOrderId] Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
     * @param {number} [aboveIcebergQty] Note that this can only be used if `aboveTimeInForce` is `GTC`.
     * @param {number} [abovePrice] Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @param {number} [aboveStopPrice] Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT` <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
     * @param {number} [aboveTrailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @param {number} [aboveTimeInForce] Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`
     * @param {number} [aboveStrategyId] Arbitrary numeric value identifying the above order within an order strategy.
     * @param {number} [aboveStrategyType] Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
     * @param {OrderListOcoBelowTypeEnum} [belowType]
     * @param {string} [belowClientOrderId] Arbitrary unique ID among open orders for the below order. Automatically generated if not sent
     * @param {number} [belowIcebergQty] Note that this can only be used if `belowTimeInForce` is `GTC`.
     * @param {number} [belowPrice] Can be used if `belowType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @param {number} [belowStopPrice] Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT` or `TAKE_PROFIT_LIMIT` <br>Either belowStopPrice or belowTrailingDelta or both, must be specified.
     * @param {number} [belowTrailingDelta] See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
     * @param {OrderListOcoBelowTimeInForceEnum} [belowTimeInForce]
     * @param {number} [belowStrategyId] Arbitrary numeric value identifying the below order within an order strategy.
     * @param {number} [belowStrategyType] Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
     * @param {OrderListOcoNewOrderRespTypeEnum} [newOrderRespType]
     * @param {OrderListOcoSelfTradePreventionModeEnum} [selfTradePreventionMode]
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    orderListOco: async (symbol, quantity, listClientOrderId, side, aboveType, aboveClientOrderId, aboveIcebergQty, abovePrice, aboveStopPrice, aboveTrailingDelta, aboveTimeInForce, aboveStrategyId, aboveStrategyType, belowType, belowClientOrderId, belowIcebergQty, belowPrice, belowStopPrice, belowTrailingDelta, belowTimeInForce, belowStrategyId, belowStrategyType, newOrderRespType, selfTradePreventionMode, recvWindow) => {
      (0, import_common4.assertParamExists)("orderListOco", "symbol", symbol);
      (0, import_common4.assertParamExists)("orderListOco", "quantity", quantity);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (listClientOrderId !== void 0 && listClientOrderId !== null) {
        localVarQueryParameter["listClientOrderId"] = listClientOrderId;
      }
      if (side !== void 0 && side !== null) {
        localVarQueryParameter["side"] = side;
      }
      if (quantity !== void 0 && quantity !== null) {
        localVarQueryParameter["quantity"] = quantity;
      }
      if (aboveType !== void 0 && aboveType !== null) {
        localVarQueryParameter["aboveType"] = aboveType;
      }
      if (aboveClientOrderId !== void 0 && aboveClientOrderId !== null) {
        localVarQueryParameter["aboveClientOrderId"] = aboveClientOrderId;
      }
      if (aboveIcebergQty !== void 0 && aboveIcebergQty !== null) {
        localVarQueryParameter["aboveIcebergQty"] = aboveIcebergQty;
      }
      if (abovePrice !== void 0 && abovePrice !== null) {
        localVarQueryParameter["abovePrice"] = abovePrice;
      }
      if (aboveStopPrice !== void 0 && aboveStopPrice !== null) {
        localVarQueryParameter["aboveStopPrice"] = aboveStopPrice;
      }
      if (aboveTrailingDelta !== void 0 && aboveTrailingDelta !== null) {
        localVarQueryParameter["aboveTrailingDelta"] = aboveTrailingDelta;
      }
      if (aboveTimeInForce !== void 0 && aboveTimeInForce !== null) {
        localVarQueryParameter["aboveTimeInForce"] = aboveTimeInForce;
      }
      if (aboveStrategyId !== void 0 && aboveStrategyId !== null) {
        localVarQueryParameter["aboveStrategyId"] = aboveStrategyId;
      }
      if (aboveStrategyType !== void 0 && aboveStrategyType !== null) {
        localVarQueryParameter["aboveStrategyType"] = aboveStrategyType;
      }
      if (belowType !== void 0 && belowType !== null) {
        localVarQueryParameter["belowType"] = belowType;
      }
      if (belowClientOrderId !== void 0 && belowClientOrderId !== null) {
        localVarQueryParameter["belowClientOrderId"] = belowClientOrderId;
      }
      if (belowIcebergQty !== void 0 && belowIcebergQty !== null) {
        localVarQueryParameter["belowIcebergQty"] = belowIcebergQty;
      }
      if (belowPrice !== void 0 && belowPrice !== null) {
        localVarQueryParameter["belowPrice"] = belowPrice;
      }
      if (belowStopPrice !== void 0 && belowStopPrice !== null) {
        localVarQueryParameter["belowStopPrice"] = belowStopPrice;
      }
      if (belowTrailingDelta !== void 0 && belowTrailingDelta !== null) {
        localVarQueryParameter["belowTrailingDelta"] = belowTrailingDelta;
      }
      if (belowTimeInForce !== void 0 && belowTimeInForce !== null) {
        localVarQueryParameter["belowTimeInForce"] = belowTimeInForce;
      }
      if (belowStrategyId !== void 0 && belowStrategyId !== null) {
        localVarQueryParameter["belowStrategyId"] = belowStrategyId;
      }
      if (belowStrategyType !== void 0 && belowStrategyType !== null) {
        localVarQueryParameter["belowStrategyType"] = belowStrategyType;
      }
      if (newOrderRespType !== void 0 && newOrderRespType !== null) {
        localVarQueryParameter["newOrderRespType"] = newOrderRespType;
      }
      if (selfTradePreventionMode !== void 0 && selfTradePreventionMode !== null) {
        localVarQueryParameter["selfTradePreventionMode"] = selfTradePreventionMode;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/orderList/oco",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Places an OTO.
     *
     * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
     * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
     * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
     * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OTO
     * @param {string} symbol
     * @param {number} workingPrice
     * @param {number} workingQuantity
     * @param {number} pendingQuantity
     * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @param {OrderListOtoNewOrderRespTypeEnum} [newOrderRespType]
     * @param {OrderListOtoSelfTradePreventionModeEnum} [selfTradePreventionMode]
     * @param {OrderListOtoWorkingTypeEnum} [workingType]
     * @param {OrderListOtoWorkingSideEnum} [workingSide]
     * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
     * @param {number} [workingIcebergQty] This can only be used if `workingTimeInForce` is `GTC`.
     * @param {OrderListOtoWorkingTimeInForceEnum} [workingTimeInForce]
     * @param {number} [workingStrategyId] Arbitrary numeric value identifying the working order within an order strategy.
     * @param {number} [workingStrategyType] Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @param {OrderListOtoPendingTypeEnum} [pendingType]
     * @param {OrderListOtoPendingSideEnum} [pendingSide]
     * @param {string} [pendingClientOrderId] Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
     * @param {number} [pendingPrice]
     * @param {number} [pendingStopPrice]
     * @param {number} [pendingTrailingDelta]
     * @param {number} [pendingIcebergQty] This can only be used if `pendingTimeInForce` is `GTC` or if `pendingType` is `LIMIT_MAKER`.
     * @param {OrderListOtoPendingTimeInForceEnum} [pendingTimeInForce]
     * @param {number} [pendingStrategyId] Arbitrary numeric value identifying the pending order within an order strategy.
     * @param {number} [pendingStrategyType] Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    orderListOto: async (symbol, workingPrice, workingQuantity, pendingQuantity, listClientOrderId, newOrderRespType, selfTradePreventionMode, workingType, workingSide, workingClientOrderId, workingIcebergQty, workingTimeInForce, workingStrategyId, workingStrategyType, pendingType, pendingSide, pendingClientOrderId, pendingPrice, pendingStopPrice, pendingTrailingDelta, pendingIcebergQty, pendingTimeInForce, pendingStrategyId, pendingStrategyType, recvWindow) => {
      (0, import_common4.assertParamExists)("orderListOto", "symbol", symbol);
      (0, import_common4.assertParamExists)("orderListOto", "workingPrice", workingPrice);
      (0, import_common4.assertParamExists)("orderListOto", "workingQuantity", workingQuantity);
      (0, import_common4.assertParamExists)("orderListOto", "pendingQuantity", pendingQuantity);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (listClientOrderId !== void 0 && listClientOrderId !== null) {
        localVarQueryParameter["listClientOrderId"] = listClientOrderId;
      }
      if (newOrderRespType !== void 0 && newOrderRespType !== null) {
        localVarQueryParameter["newOrderRespType"] = newOrderRespType;
      }
      if (selfTradePreventionMode !== void 0 && selfTradePreventionMode !== null) {
        localVarQueryParameter["selfTradePreventionMode"] = selfTradePreventionMode;
      }
      if (workingType !== void 0 && workingType !== null) {
        localVarQueryParameter["workingType"] = workingType;
      }
      if (workingSide !== void 0 && workingSide !== null) {
        localVarQueryParameter["workingSide"] = workingSide;
      }
      if (workingClientOrderId !== void 0 && workingClientOrderId !== null) {
        localVarQueryParameter["workingClientOrderId"] = workingClientOrderId;
      }
      if (workingPrice !== void 0 && workingPrice !== null) {
        localVarQueryParameter["workingPrice"] = workingPrice;
      }
      if (workingQuantity !== void 0 && workingQuantity !== null) {
        localVarQueryParameter["workingQuantity"] = workingQuantity;
      }
      if (workingIcebergQty !== void 0 && workingIcebergQty !== null) {
        localVarQueryParameter["workingIcebergQty"] = workingIcebergQty;
      }
      if (workingTimeInForce !== void 0 && workingTimeInForce !== null) {
        localVarQueryParameter["workingTimeInForce"] = workingTimeInForce;
      }
      if (workingStrategyId !== void 0 && workingStrategyId !== null) {
        localVarQueryParameter["workingStrategyId"] = workingStrategyId;
      }
      if (workingStrategyType !== void 0 && workingStrategyType !== null) {
        localVarQueryParameter["workingStrategyType"] = workingStrategyType;
      }
      if (pendingType !== void 0 && pendingType !== null) {
        localVarQueryParameter["pendingType"] = pendingType;
      }
      if (pendingSide !== void 0 && pendingSide !== null) {
        localVarQueryParameter["pendingSide"] = pendingSide;
      }
      if (pendingClientOrderId !== void 0 && pendingClientOrderId !== null) {
        localVarQueryParameter["pendingClientOrderId"] = pendingClientOrderId;
      }
      if (pendingPrice !== void 0 && pendingPrice !== null) {
        localVarQueryParameter["pendingPrice"] = pendingPrice;
      }
      if (pendingStopPrice !== void 0 && pendingStopPrice !== null) {
        localVarQueryParameter["pendingStopPrice"] = pendingStopPrice;
      }
      if (pendingTrailingDelta !== void 0 && pendingTrailingDelta !== null) {
        localVarQueryParameter["pendingTrailingDelta"] = pendingTrailingDelta;
      }
      if (pendingQuantity !== void 0 && pendingQuantity !== null) {
        localVarQueryParameter["pendingQuantity"] = pendingQuantity;
      }
      if (pendingIcebergQty !== void 0 && pendingIcebergQty !== null) {
        localVarQueryParameter["pendingIcebergQty"] = pendingIcebergQty;
      }
      if (pendingTimeInForce !== void 0 && pendingTimeInForce !== null) {
        localVarQueryParameter["pendingTimeInForce"] = pendingTimeInForce;
      }
      if (pendingStrategyId !== void 0 && pendingStrategyId !== null) {
        localVarQueryParameter["pendingStrategyId"] = pendingStrategyId;
      }
      if (pendingStrategyType !== void 0 && pendingStrategyType !== null) {
        localVarQueryParameter["pendingStrategyType"] = pendingStrategyType;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/orderList/oto",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Place an OTOCO.
     *
     * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
     *
     * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
     * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
     * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
     * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
     * OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New Order list - OTOCO
     * @param {string} symbol
     * @param {number} workingPrice
     * @param {number} workingQuantity
     * @param {number} pendingQuantity
     * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @param {OrderListOtocoNewOrderRespTypeEnum} [newOrderRespType]
     * @param {OrderListOtocoSelfTradePreventionModeEnum} [selfTradePreventionMode]
     * @param {OrderListOtocoWorkingTypeEnum} [workingType]
     * @param {OrderListOtocoWorkingSideEnum} [workingSide]
     * @param {string} [workingClientOrderId] Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
     * @param {number} [workingIcebergQty] This can only be used if `workingTimeInForce` is `GTC`.
     * @param {OrderListOtocoWorkingTimeInForceEnum} [workingTimeInForce]
     * @param {number} [workingStrategyId] Arbitrary numeric value identifying the working order within an order strategy.
     * @param {number} [workingStrategyType] Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @param {OrderListOtocoPendingSideEnum} [pendingSide]
     * @param {OrderListOtocoPendingAboveTypeEnum} [pendingAboveType]
     * @param {string} [pendingAboveClientOrderId] Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
     * @param {number} [pendingAbovePrice] Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
     * @param {number} [pendingAboveStopPrice] Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
     * @param {number} [pendingAboveTrailingDelta] See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
     * @param {number} [pendingAboveIcebergQty] This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
     * @param {OrderListOtocoPendingAboveTimeInForceEnum} [pendingAboveTimeInForce]
     * @param {number} [pendingAboveStrategyId] Arbitrary numeric value identifying the pending above order within an order strategy.
     * @param {number} [pendingAboveStrategyType] Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @param {OrderListOtocoPendingBelowTypeEnum} [pendingBelowType]
     * @param {string} [pendingBelowClientOrderId] Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
     * @param {number} [pendingBelowPrice] Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify limit price
     * @param {number} [pendingBelowStopPrice] Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br> Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
     * @param {number} [pendingBelowTrailingDelta]
     * @param {number} [pendingBelowIcebergQty] This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
     * @param {OrderListOtocoPendingBelowTimeInForceEnum} [pendingBelowTimeInForce]
     * @param {number} [pendingBelowStrategyId] Arbitrary numeric value identifying the pending below order within an order strategy.
     * @param {number} [pendingBelowStrategyType] Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    orderListOtoco: async (symbol, workingPrice, workingQuantity, pendingQuantity, listClientOrderId, newOrderRespType, selfTradePreventionMode, workingType, workingSide, workingClientOrderId, workingIcebergQty, workingTimeInForce, workingStrategyId, workingStrategyType, pendingSide, pendingAboveType, pendingAboveClientOrderId, pendingAbovePrice, pendingAboveStopPrice, pendingAboveTrailingDelta, pendingAboveIcebergQty, pendingAboveTimeInForce, pendingAboveStrategyId, pendingAboveStrategyType, pendingBelowType, pendingBelowClientOrderId, pendingBelowPrice, pendingBelowStopPrice, pendingBelowTrailingDelta, pendingBelowIcebergQty, pendingBelowTimeInForce, pendingBelowStrategyId, pendingBelowStrategyType, recvWindow) => {
      (0, import_common4.assertParamExists)("orderListOtoco", "symbol", symbol);
      (0, import_common4.assertParamExists)("orderListOtoco", "workingPrice", workingPrice);
      (0, import_common4.assertParamExists)("orderListOtoco", "workingQuantity", workingQuantity);
      (0, import_common4.assertParamExists)("orderListOtoco", "pendingQuantity", pendingQuantity);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (listClientOrderId !== void 0 && listClientOrderId !== null) {
        localVarQueryParameter["listClientOrderId"] = listClientOrderId;
      }
      if (newOrderRespType !== void 0 && newOrderRespType !== null) {
        localVarQueryParameter["newOrderRespType"] = newOrderRespType;
      }
      if (selfTradePreventionMode !== void 0 && selfTradePreventionMode !== null) {
        localVarQueryParameter["selfTradePreventionMode"] = selfTradePreventionMode;
      }
      if (workingType !== void 0 && workingType !== null) {
        localVarQueryParameter["workingType"] = workingType;
      }
      if (workingSide !== void 0 && workingSide !== null) {
        localVarQueryParameter["workingSide"] = workingSide;
      }
      if (workingClientOrderId !== void 0 && workingClientOrderId !== null) {
        localVarQueryParameter["workingClientOrderId"] = workingClientOrderId;
      }
      if (workingPrice !== void 0 && workingPrice !== null) {
        localVarQueryParameter["workingPrice"] = workingPrice;
      }
      if (workingQuantity !== void 0 && workingQuantity !== null) {
        localVarQueryParameter["workingQuantity"] = workingQuantity;
      }
      if (workingIcebergQty !== void 0 && workingIcebergQty !== null) {
        localVarQueryParameter["workingIcebergQty"] = workingIcebergQty;
      }
      if (workingTimeInForce !== void 0 && workingTimeInForce !== null) {
        localVarQueryParameter["workingTimeInForce"] = workingTimeInForce;
      }
      if (workingStrategyId !== void 0 && workingStrategyId !== null) {
        localVarQueryParameter["workingStrategyId"] = workingStrategyId;
      }
      if (workingStrategyType !== void 0 && workingStrategyType !== null) {
        localVarQueryParameter["workingStrategyType"] = workingStrategyType;
      }
      if (pendingSide !== void 0 && pendingSide !== null) {
        localVarQueryParameter["pendingSide"] = pendingSide;
      }
      if (pendingQuantity !== void 0 && pendingQuantity !== null) {
        localVarQueryParameter["pendingQuantity"] = pendingQuantity;
      }
      if (pendingAboveType !== void 0 && pendingAboveType !== null) {
        localVarQueryParameter["pendingAboveType"] = pendingAboveType;
      }
      if (pendingAboveClientOrderId !== void 0 && pendingAboveClientOrderId !== null) {
        localVarQueryParameter["pendingAboveClientOrderId"] = pendingAboveClientOrderId;
      }
      if (pendingAbovePrice !== void 0 && pendingAbovePrice !== null) {
        localVarQueryParameter["pendingAbovePrice"] = pendingAbovePrice;
      }
      if (pendingAboveStopPrice !== void 0 && pendingAboveStopPrice !== null) {
        localVarQueryParameter["pendingAboveStopPrice"] = pendingAboveStopPrice;
      }
      if (pendingAboveTrailingDelta !== void 0 && pendingAboveTrailingDelta !== null) {
        localVarQueryParameter["pendingAboveTrailingDelta"] = pendingAboveTrailingDelta;
      }
      if (pendingAboveIcebergQty !== void 0 && pendingAboveIcebergQty !== null) {
        localVarQueryParameter["pendingAboveIcebergQty"] = pendingAboveIcebergQty;
      }
      if (pendingAboveTimeInForce !== void 0 && pendingAboveTimeInForce !== null) {
        localVarQueryParameter["pendingAboveTimeInForce"] = pendingAboveTimeInForce;
      }
      if (pendingAboveStrategyId !== void 0 && pendingAboveStrategyId !== null) {
        localVarQueryParameter["pendingAboveStrategyId"] = pendingAboveStrategyId;
      }
      if (pendingAboveStrategyType !== void 0 && pendingAboveStrategyType !== null) {
        localVarQueryParameter["pendingAboveStrategyType"] = pendingAboveStrategyType;
      }
      if (pendingBelowType !== void 0 && pendingBelowType !== null) {
        localVarQueryParameter["pendingBelowType"] = pendingBelowType;
      }
      if (pendingBelowClientOrderId !== void 0 && pendingBelowClientOrderId !== null) {
        localVarQueryParameter["pendingBelowClientOrderId"] = pendingBelowClientOrderId;
      }
      if (pendingBelowPrice !== void 0 && pendingBelowPrice !== null) {
        localVarQueryParameter["pendingBelowPrice"] = pendingBelowPrice;
      }
      if (pendingBelowStopPrice !== void 0 && pendingBelowStopPrice !== null) {
        localVarQueryParameter["pendingBelowStopPrice"] = pendingBelowStopPrice;
      }
      if (pendingBelowTrailingDelta !== void 0 && pendingBelowTrailingDelta !== null) {
        localVarQueryParameter["pendingBelowTrailingDelta"] = pendingBelowTrailingDelta;
      }
      if (pendingBelowIcebergQty !== void 0 && pendingBelowIcebergQty !== null) {
        localVarQueryParameter["pendingBelowIcebergQty"] = pendingBelowIcebergQty;
      }
      if (pendingBelowTimeInForce !== void 0 && pendingBelowTimeInForce !== null) {
        localVarQueryParameter["pendingBelowTimeInForce"] = pendingBelowTimeInForce;
      }
      if (pendingBelowStrategyId !== void 0 && pendingBelowStrategyId !== null) {
        localVarQueryParameter["pendingBelowStrategyId"] = pendingBelowStrategyId;
      }
      if (pendingBelowStrategyType !== void 0 && pendingBelowStrategyType !== null) {
        localVarQueryParameter["pendingBelowStrategyType"] = pendingBelowStrategyType;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/orderList/otoco",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Send in a new OCO.
     *
     * Price Restrictions:
     * `SELL`: Limit Price > Last Price > Stop Price
     * `BUY`: Limit Price < Last Price < Stop Price
     * Quantity Restrictions:
     * Both legs must have the same quantity.
     * `ICEBERG` quantities however do not have to be the same
     * `OCO` adds **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
     * Weight: 1
     *
     * @summary New OCO - Deprecated
     * @param {string} symbol
     * @param {number} quantity
     * @param {number} stopPrice
     * @param {string} [listClientOrderId] Arbitrary unique ID among open order lists. Automatically generated if not sent. <br>A new order list with the same listClientOrderId is accepted only when the previous one is filled or completely expired. <br> `listClientOrderId` is distinct from the `workingClientOrderId`, `pendingAboveClientOrderId`, and the `pendingBelowClientOrderId`.
     * @param {OrderOcoSideEnum} [side]
     * @param {string} [limitClientOrderId] A unique Id for the limit order
     * @param {number} [price]
     * @param {number} [limitStrategyId]
     * @param {number} [limitStrategyType] The value cannot be less than `1000000`.
     * @param {number} [limitIcebergQty] Used to make the `LIMIT_MAKER` leg an iceberg order.
     * @param {number} [trailingDelta]
     * @param {string} [stopClientOrderId] A unique Id for the stop loss/stop loss limit leg
     * @param {number} [stopStrategyId]
     * @param {number} [stopStrategyType] The value cannot be less than `1000000`.
     * @param {number} [stopLimitPrice] If provided, `stopLimitTimeInForce` is required.
     * @param {number} [stopIcebergQty] Used with `STOP_LOSS_LIMIT` leg to make an iceberg order.
     * @param {OrderOcoStopLimitTimeInForceEnum} [stopLimitTimeInForce]
     * @param {OrderOcoNewOrderRespTypeEnum} [newOrderRespType]
     * @param {OrderOcoSelfTradePreventionModeEnum} [selfTradePreventionMode]
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    orderOco: async (symbol, quantity, stopPrice, listClientOrderId, side, limitClientOrderId, price, limitStrategyId, limitStrategyType, limitIcebergQty, trailingDelta, stopClientOrderId, stopStrategyId, stopStrategyType, stopLimitPrice, stopIcebergQty, stopLimitTimeInForce, newOrderRespType, selfTradePreventionMode, recvWindow) => {
      (0, import_common4.assertParamExists)("orderOco", "symbol", symbol);
      (0, import_common4.assertParamExists)("orderOco", "quantity", quantity);
      (0, import_common4.assertParamExists)("orderOco", "stopPrice", stopPrice);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (listClientOrderId !== void 0 && listClientOrderId !== null) {
        localVarQueryParameter["listClientOrderId"] = listClientOrderId;
      }
      if (side !== void 0 && side !== null) {
        localVarQueryParameter["side"] = side;
      }
      if (quantity !== void 0 && quantity !== null) {
        localVarQueryParameter["quantity"] = quantity;
      }
      if (limitClientOrderId !== void 0 && limitClientOrderId !== null) {
        localVarQueryParameter["limitClientOrderId"] = limitClientOrderId;
      }
      if (price !== void 0 && price !== null) {
        localVarQueryParameter["price"] = price;
      }
      if (limitStrategyId !== void 0 && limitStrategyId !== null) {
        localVarQueryParameter["limitStrategyId"] = limitStrategyId;
      }
      if (limitStrategyType !== void 0 && limitStrategyType !== null) {
        localVarQueryParameter["limitStrategyType"] = limitStrategyType;
      }
      if (limitIcebergQty !== void 0 && limitIcebergQty !== null) {
        localVarQueryParameter["limitIcebergQty"] = limitIcebergQty;
      }
      if (trailingDelta !== void 0 && trailingDelta !== null) {
        localVarQueryParameter["trailingDelta"] = trailingDelta;
      }
      if (stopClientOrderId !== void 0 && stopClientOrderId !== null) {
        localVarQueryParameter["stopClientOrderId"] = stopClientOrderId;
      }
      if (stopPrice !== void 0 && stopPrice !== null) {
        localVarQueryParameter["stopPrice"] = stopPrice;
      }
      if (stopStrategyId !== void 0 && stopStrategyId !== null) {
        localVarQueryParameter["stopStrategyId"] = stopStrategyId;
      }
      if (stopStrategyType !== void 0 && stopStrategyType !== null) {
        localVarQueryParameter["stopStrategyType"] = stopStrategyType;
      }
      if (stopLimitPrice !== void 0 && stopLimitPrice !== null) {
        localVarQueryParameter["stopLimitPrice"] = stopLimitPrice;
      }
      if (stopIcebergQty !== void 0 && stopIcebergQty !== null) {
        localVarQueryParameter["stopIcebergQty"] = stopIcebergQty;
      }
      if (stopLimitTimeInForce !== void 0 && stopLimitTimeInForce !== null) {
        localVarQueryParameter["stopLimitTimeInForce"] = stopLimitTimeInForce;
      }
      if (newOrderRespType !== void 0 && newOrderRespType !== null) {
        localVarQueryParameter["newOrderRespType"] = newOrderRespType;
      }
      if (selfTradePreventionMode !== void 0 && selfTradePreventionMode !== null) {
        localVarQueryParameter["selfTradePreventionMode"] = selfTradePreventionMode;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/order/oco",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Test new order creation and signature/recvWindow long.
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: |Condition| Request Weight|
     * |------------           | ------------ |
     * |Without `computeCommissionRates`| 1|
     * |With `computeCommissionRates`|20|
     *
     * @summary Test new order
     * @param {boolean} [computeCommissionRates] Default: `false`
     *
     * @throws {RequiredError}
     */
    orderTest: async (computeCommissionRates) => {
      const localVarQueryParameter = {};
      if (computeCommissionRates !== void 0 && computeCommissionRates !== null) {
        localVarQueryParameter["computeCommissionRates"] = computeCommissionRates;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/order/test",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Places an order using smart order routing (SOR).
     * Weight: 1
     *
     * @summary New order using SOR
     * @param {string} symbol
     * @param {number} quantity
     * @param {SorOrderSideEnum} [side]
     * @param {SorOrderTypeEnum} [type]
     * @param {SorOrderTimeInForceEnum} [timeInForce]
     * @param {number} [price]
     * @param {string} [newClientOrderId] A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
     * @param {number} [strategyId]
     * @param {number} [strategyType] The value cannot be less than `1000000`.
     * @param {number} [icebergQty] Used with `LIMIT` to create an iceberg order.
     * @param {SorOrderNewOrderRespTypeEnum} [newOrderRespType]
     * @param {SorOrderSelfTradePreventionModeEnum} [selfTradePreventionMode]
     * @param {number} [recvWindow] The value cannot be greater than ```60000```
     *
     * @throws {RequiredError}
     */
    sorOrder: async (symbol, quantity, side, type, timeInForce, price, newClientOrderId, strategyId, strategyType, icebergQty, newOrderRespType, selfTradePreventionMode, recvWindow) => {
      (0, import_common4.assertParamExists)("sorOrder", "symbol", symbol);
      (0, import_common4.assertParamExists)("sorOrder", "quantity", quantity);
      const localVarQueryParameter = {};
      if (symbol !== void 0 && symbol !== null) {
        localVarQueryParameter["symbol"] = symbol;
      }
      if (side !== void 0 && side !== null) {
        localVarQueryParameter["side"] = side;
      }
      if (type !== void 0 && type !== null) {
        localVarQueryParameter["type"] = type;
      }
      if (timeInForce !== void 0 && timeInForce !== null) {
        localVarQueryParameter["timeInForce"] = timeInForce;
      }
      if (quantity !== void 0 && quantity !== null) {
        localVarQueryParameter["quantity"] = quantity;
      }
      if (price !== void 0 && price !== null) {
        localVarQueryParameter["price"] = price;
      }
      if (newClientOrderId !== void 0 && newClientOrderId !== null) {
        localVarQueryParameter["newClientOrderId"] = newClientOrderId;
      }
      if (strategyId !== void 0 && strategyId !== null) {
        localVarQueryParameter["strategyId"] = strategyId;
      }
      if (strategyType !== void 0 && strategyType !== null) {
        localVarQueryParameter["strategyType"] = strategyType;
      }
      if (icebergQty !== void 0 && icebergQty !== null) {
        localVarQueryParameter["icebergQty"] = icebergQty;
      }
      if (newOrderRespType !== void 0 && newOrderRespType !== null) {
        localVarQueryParameter["newOrderRespType"] = newOrderRespType;
      }
      if (selfTradePreventionMode !== void 0 && selfTradePreventionMode !== null) {
        localVarQueryParameter["selfTradePreventionMode"] = selfTradePreventionMode;
      }
      if (recvWindow !== void 0 && recvWindow !== null) {
        localVarQueryParameter["recvWindow"] = recvWindow;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/sor/order",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Test new order creation and signature/recvWindow using smart order routing (SOR).
     * Creates and validates a new order but does not send it into the matching engine.
     * Weight: | Condition | Request Weight |
     * | --------- | -------------- |
     * | Without `computeCommissionRates`  |  1 |
     * | With `computeCommissionRates`     | 20 |
     *
     * @summary Test new order using SOR
     * @param {boolean} [computeCommissionRates] Default: `false`
     *
     * @throws {RequiredError}
     */
    sorOrderTest: async (computeCommissionRates) => {
      const localVarQueryParameter = {};
      if (computeCommissionRates !== void 0 && computeCommissionRates !== null) {
        localVarQueryParameter["computeCommissionRates"] = computeCommissionRates;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/sor/order/test",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    }
  };
};
var TradeApi = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration);
  }
  /**
   * Retrieves all order lists based on provided optional parameters.
   *
   * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
   * Weight: 20
   *
   * @summary Query all Order lists
   * @param {AllOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AllOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-all-order-lists-user_data Binance API Documentation}
   */
  async allOrderList(requestParameters = {}) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrderList(
      requestParameters?.fromId,
      requestParameters?.startTime,
      requestParameters?.endTime,
      requestParameters?.limit,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Get all account orders; active, canceled, or filled.
   * Weight: 20
   *
   * @summary All orders
   * @param {AllOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AllOrdersResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data Binance API Documentation}
   */
  async allOrders(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.allOrders(
      requestParameters?.symbol,
      requestParameters?.orderId,
      requestParameters?.startTime,
      requestParameters?.endTime,
      requestParameters?.limit,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Cancels all active orders on a symbol.
   * This includes orders that are part of an order list.
   * Weight: 1
   *
   * @summary Cancel All Open Orders on a Symbol
   * @param {DeleteOpenOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DeleteOpenOrdersResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade Binance API Documentation}
   */
  async deleteOpenOrders(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOpenOrders(
      requestParameters?.symbol,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Cancel an active order.
   * Weight: 1
   *
   * @summary Cancel order
   * @param {DeleteOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DeleteOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade Binance API Documentation}
   */
  async deleteOrder(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOrder(
      requestParameters?.symbol,
      requestParameters?.orderId,
      requestParameters?.origClientOrderId,
      requestParameters?.newClientOrderId,
      requestParameters?.cancelRestrictions,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Cancel an entire Order list
   * Weight: 1
   *
   * @summary Cancel Order list
   * @param {DeleteOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DeleteOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-list-trade Binance API Documentation}
   */
  async deleteOrderList(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteOrderList(
      requestParameters?.symbol,
      requestParameters?.orderListId,
      requestParameters?.listClientOrderId,
      requestParameters?.newClientOrderId,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
   * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
   *
   * @summary Current open orders
   * @param {GetOpenOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetOpenOrdersResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#current-open-orders-user_data Binance API Documentation}
   */
  async getOpenOrders(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOpenOrders(
      requestParameters?.symbol,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Check an order's status.
   * Weight: 4
   *
   * @summary Query order
   * @param {GetOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-user_data Binance API Documentation}
   */
  async getOrder(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrder(
      requestParameters?.symbol,
      requestParameters?.orderId,
      requestParameters?.origClientOrderId,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Retrieves a specific order list based on provided optional parameters.
   * Weight: 4
   *
   * @summary Query Order list
   * @param {GetOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-list-user_data Binance API Documentation}
   */
  async getOrderList(requestParameters = {}) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.getOrderList(
      requestParameters?.orderListId,
      requestParameters?.origClientOrderId,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Send in a new order.
   * Weight: 1
   *
   * @summary New order
   * @param {NewOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<NewOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade Binance API Documentation}
   */
  async newOrder(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.newOrder(
      requestParameters?.symbol,
      requestParameters?.quantity,
      requestParameters?.stopPrice,
      requestParameters?.side,
      requestParameters?.type,
      requestParameters?.timeInForce,
      requestParameters?.quoteOrderQty,
      requestParameters?.price,
      requestParameters?.newClientOrderId,
      requestParameters?.strategyId,
      requestParameters?.strategyType,
      requestParameters?.trailingDelta,
      requestParameters?.icebergQty,
      requestParameters?.newOrderRespType,
      requestParameters?.selfTradePreventionMode,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   *
   * Weight: 6
   *
   * @summary Query Open Order lists
   * @param {OpenOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OpenOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-open-order-lists-user_data Binance API Documentation}
   */
  async openOrderList(requestParameters = {}) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.openOrderList(
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Cancels an existing order and places a new order on the same symbol.
   *
   * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
   *
   * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED` ), will still increase the order count by 1.
   * Weight: 1
   *
   * @summary Cancel an Existing Order and Send a New Order
   * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderCancelReplaceResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade Binance API Documentation}
   */
  async orderCancelReplace(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderCancelReplace(
      requestParameters?.symbol,
      requestParameters?.quantity,
      requestParameters?.stopPrice,
      requestParameters?.side,
      requestParameters?.type,
      requestParameters?.cancelReplaceMode,
      requestParameters?.timeInForce,
      requestParameters?.quoteOrderQty,
      requestParameters?.price,
      requestParameters?.cancelNewClientOrderId,
      requestParameters?.cancelOrigClientOrderId,
      requestParameters?.cancelOrderId,
      requestParameters?.newClientOrderId,
      requestParameters?.strategyId,
      requestParameters?.strategyType,
      requestParameters?.trailingDelta,
      requestParameters?.icebergQty,
      requestParameters?.newOrderRespType,
      requestParameters?.selfTradePreventionMode,
      requestParameters?.cancelRestrictions,
      requestParameters?.orderRateLimitExceededMode,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
   *
   * An OCO has 2 orders called the **above order** and **below order**.
   * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
   * Price restrictions
   * If the OCO is on the `SELL` side:
   * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
   * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * If the OCO is on the `BUY` side:
   * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
   * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and the `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New Order list - OCO
   * @param {OrderListOcoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderListOcoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade Binance API Documentation}
   */
  async orderListOco(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOco(
      requestParameters?.symbol,
      requestParameters?.quantity,
      requestParameters?.listClientOrderId,
      requestParameters?.side,
      requestParameters?.aboveType,
      requestParameters?.aboveClientOrderId,
      requestParameters?.aboveIcebergQty,
      requestParameters?.abovePrice,
      requestParameters?.aboveStopPrice,
      requestParameters?.aboveTrailingDelta,
      requestParameters?.aboveTimeInForce,
      requestParameters?.aboveStrategyId,
      requestParameters?.aboveStrategyType,
      requestParameters?.belowType,
      requestParameters?.belowClientOrderId,
      requestParameters?.belowIcebergQty,
      requestParameters?.belowPrice,
      requestParameters?.belowStopPrice,
      requestParameters?.belowTrailingDelta,
      requestParameters?.belowTimeInForce,
      requestParameters?.belowStrategyId,
      requestParameters?.belowStrategyType,
      requestParameters?.newOrderRespType,
      requestParameters?.selfTradePreventionMode,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Places an OTO.
   *
   * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
   * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
   * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
   * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New Order list - OTO
   * @param {OrderListOtoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderListOtoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oto-trade Binance API Documentation}
   */
  async orderListOto(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOto(
      requestParameters?.symbol,
      requestParameters?.workingPrice,
      requestParameters?.workingQuantity,
      requestParameters?.pendingQuantity,
      requestParameters?.listClientOrderId,
      requestParameters?.newOrderRespType,
      requestParameters?.selfTradePreventionMode,
      requestParameters?.workingType,
      requestParameters?.workingSide,
      requestParameters?.workingClientOrderId,
      requestParameters?.workingIcebergQty,
      requestParameters?.workingTimeInForce,
      requestParameters?.workingStrategyId,
      requestParameters?.workingStrategyType,
      requestParameters?.pendingType,
      requestParameters?.pendingSide,
      requestParameters?.pendingClientOrderId,
      requestParameters?.pendingPrice,
      requestParameters?.pendingStopPrice,
      requestParameters?.pendingTrailingDelta,
      requestParameters?.pendingIcebergQty,
      requestParameters?.pendingTimeInForce,
      requestParameters?.pendingStrategyId,
      requestParameters?.pendingStrategyType,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Place an OTOCO.
   *
   * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
   *
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
   * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
   * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
   * OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New Order list - OTOCO
   * @param {OrderListOtocoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderListOtocoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---otoco-trade Binance API Documentation}
   */
  async orderListOtoco(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderListOtoco(
      requestParameters?.symbol,
      requestParameters?.workingPrice,
      requestParameters?.workingQuantity,
      requestParameters?.pendingQuantity,
      requestParameters?.listClientOrderId,
      requestParameters?.newOrderRespType,
      requestParameters?.selfTradePreventionMode,
      requestParameters?.workingType,
      requestParameters?.workingSide,
      requestParameters?.workingClientOrderId,
      requestParameters?.workingIcebergQty,
      requestParameters?.workingTimeInForce,
      requestParameters?.workingStrategyId,
      requestParameters?.workingStrategyType,
      requestParameters?.pendingSide,
      requestParameters?.pendingAboveType,
      requestParameters?.pendingAboveClientOrderId,
      requestParameters?.pendingAbovePrice,
      requestParameters?.pendingAboveStopPrice,
      requestParameters?.pendingAboveTrailingDelta,
      requestParameters?.pendingAboveIcebergQty,
      requestParameters?.pendingAboveTimeInForce,
      requestParameters?.pendingAboveStrategyId,
      requestParameters?.pendingAboveStrategyType,
      requestParameters?.pendingBelowType,
      requestParameters?.pendingBelowClientOrderId,
      requestParameters?.pendingBelowPrice,
      requestParameters?.pendingBelowStopPrice,
      requestParameters?.pendingBelowTrailingDelta,
      requestParameters?.pendingBelowIcebergQty,
      requestParameters?.pendingBelowTimeInForce,
      requestParameters?.pendingBelowStrategyId,
      requestParameters?.pendingBelowStrategyType,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Send in a new OCO.
   *
   * Price Restrictions:
   * `SELL`: Limit Price > Last Price > Stop Price
   * `BUY`: Limit Price < Last Price < Stop Price
   * Quantity Restrictions:
   * Both legs must have the same quantity.
   * `ICEBERG` quantities however do not have to be the same
   * `OCO` adds **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New OCO - Deprecated
   * @param {OrderOcoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderOcoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-oco---deprecated-trade Binance API Documentation}
   */
  async orderOco(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderOco(
      requestParameters?.symbol,
      requestParameters?.quantity,
      requestParameters?.stopPrice,
      requestParameters?.listClientOrderId,
      requestParameters?.side,
      requestParameters?.limitClientOrderId,
      requestParameters?.price,
      requestParameters?.limitStrategyId,
      requestParameters?.limitStrategyType,
      requestParameters?.limitIcebergQty,
      requestParameters?.trailingDelta,
      requestParameters?.stopClientOrderId,
      requestParameters?.stopStrategyId,
      requestParameters?.stopStrategyType,
      requestParameters?.stopLimitPrice,
      requestParameters?.stopIcebergQty,
      requestParameters?.stopLimitTimeInForce,
      requestParameters?.newOrderRespType,
      requestParameters?.selfTradePreventionMode,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Test new order creation and signature/recvWindow long.
   * Creates and validates a new order but does not send it into the matching engine.
   * Weight: |Condition| Request Weight|
   * |------------           | ------------ |
   * |Without `computeCommissionRates`| 1|
   * |With `computeCommissionRates`|20|
   *
   * @summary Test new order
   * @param {OrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-trade Binance API Documentation}
   */
  async orderTest(requestParameters = {}) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.orderTest(
      requestParameters?.computeCommissionRates
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Places an order using smart order routing (SOR).
   * Weight: 1
   *
   * @summary New order using SOR
   * @param {SorOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<SorOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-using-sor-trade Binance API Documentation}
   */
  async sorOrder(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.sorOrder(
      requestParameters?.symbol,
      requestParameters?.quantity,
      requestParameters?.side,
      requestParameters?.type,
      requestParameters?.timeInForce,
      requestParameters?.price,
      requestParameters?.newClientOrderId,
      requestParameters?.strategyId,
      requestParameters?.strategyType,
      requestParameters?.icebergQty,
      requestParameters?.newOrderRespType,
      requestParameters?.selfTradePreventionMode,
      requestParameters?.recvWindow
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
  /**
   * Test new order creation and signature/recvWindow using smart order routing (SOR).
   * Creates and validates a new order but does not send it into the matching engine.
   * Weight: | Condition | Request Weight |
   * | --------- | -------------- |
   * | Without `computeCommissionRates`  |  1 |
   * | With `computeCommissionRates`     | 20 |
   *
   * @summary Test new order using SOR
   * @param {SorOrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<SorOrderTestResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-using-sor-trade Binance API Documentation}
   */
  async sorOrderTest(requestParameters = {}) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.sorOrderTest(
      requestParameters?.computeCommissionRates
    );
    return (0, import_common4.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: true }
    );
  }
};
var DeleteOrderCancelRestrictionsEnum = {
  ONLY_NEW: "ONLY_NEW",
  NEW: "NEW",
  ONLY_PARTIALLY_FILLED: "ONLY_PARTIALLY_FILLED",
  PARTIALLY_FILLED: "PARTIALLY_FILLED"
};
var NewOrderSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var NewOrderTypeEnum = {
  MARKET: "MARKET",
  LIMIT: "LIMIT",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var NewOrderTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var NewOrderNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var NewOrderSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderCancelReplaceSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderCancelReplaceTypeEnum = {
  MARKET: "MARKET",
  LIMIT: "LIMIT",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderCancelReplaceCancelReplaceModeEnum = {
  STOP_ON_FAILURE: "STOP_ON_FAILURE",
  ALLOW_FAILURE: "ALLOW_FAILURE"
};
var OrderCancelReplaceTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderCancelReplaceNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderCancelReplaceSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderCancelReplaceCancelRestrictionsEnum = {
  ONLY_NEW: "ONLY_NEW",
  NEW: "NEW",
  ONLY_PARTIALLY_FILLED: "ONLY_PARTIALLY_FILLED",
  PARTIALLY_FILLED: "PARTIALLY_FILLED"
};
var OrderCancelReplaceOrderRateLimitExceededModeEnum = {
  DO_NOTHING: "DO_NOTHING",
  CANCEL_ONLY: "CANCEL_ONLY"
};
var OrderListOcoSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListOcoAboveTypeEnum = {
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  STOP_LOSS: "STOP_LOSS",
  LIMIT_MAKER: "LIMIT_MAKER",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListOcoBelowTypeEnum = {
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListOcoBelowTimeInForceEnum = {
  belowType: "belowType",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListOcoNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderListOcoSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderListOtoNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderListOtoSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderListOtoWorkingTypeEnum = {
  LIMIT: "LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderListOtoWorkingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListOtoWorkingTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListOtoPendingTypeEnum = {
  LIMIT: "LIMIT",
  MARKET: "MARKET",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderListOtoPendingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListOtoPendingTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListOtocoNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderListOtocoSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderListOtocoWorkingTypeEnum = {
  LIMIT: "LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderListOtocoWorkingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListOtocoWorkingTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListOtocoPendingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListOtocoPendingAboveTypeEnum = {
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  STOP_LOSS: "STOP_LOSS",
  LIMIT_MAKER: "LIMIT_MAKER",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListOtocoPendingAboveTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListOtocoPendingBelowTypeEnum = {
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListOtocoPendingBelowTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderOcoSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderOcoStopLimitTimeInForceEnum = {
  GTC: "GTC",
  FOK: "FOK",
  IOC: "IOC"
};
var OrderOcoNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderOcoSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var SorOrderSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var SorOrderTypeEnum = {
  MARKET: "MARKET",
  LIMIT: "LIMIT",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var SorOrderTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var SorOrderNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var SorOrderSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};

// src/rest-api/modules/userdatastream-api.ts
var import_common5 = require("@binance/common");
var UserdatastreamApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Close out a user data stream.
     * Weight: 2
     *
     * @summary Close user data stream
     * @param {string} listenKey
     *
     * @throws {RequiredError}
     */
    deleteUserDataStream: async (listenKey) => {
      (0, import_common5.assertParamExists)("deleteUserDataStream", "listenKey", listenKey);
      const localVarQueryParameter = {};
      if (listenKey !== void 0 && listenKey !== null) {
        localVarQueryParameter["listenKey"] = listenKey;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/userDataStream",
        method: "DELETE",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
     * Weight: 2
     *
     * @summary Start user data stream
     *
     * @throws {RequiredError}
     */
    newUserDataStream: async () => {
      const localVarQueryParameter = {};
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/userDataStream",
        method: "POST",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    },
    /**
     * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.
     * Weight: 2
     *
     * @summary Keepalive user data stream
     * @param {string} listenKey
     *
     * @throws {RequiredError}
     */
    putUserDataStream: async (listenKey) => {
      (0, import_common5.assertParamExists)("putUserDataStream", "listenKey", listenKey);
      const localVarQueryParameter = {};
      if (listenKey !== void 0 && listenKey !== null) {
        localVarQueryParameter["listenKey"] = listenKey;
      }
      let _timeUnit;
      if ("timeUnit" in configuration)
        _timeUnit = configuration.timeUnit;
      return {
        endpoint: "/api/v3/userDataStream",
        method: "PUT",
        params: localVarQueryParameter,
        timeUnit: _timeUnit
      };
    }
  };
};
var UserdatastreamApi = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.localVarAxiosParamCreator = UserdatastreamApiAxiosParamCreator(configuration);
  }
  /**
   * Close out a user data stream.
   * Weight: 2
   *
   * @summary Close user data stream
   * @param {DeleteUserDataStreamRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof UserdatastreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/user-data-stream-endpoints#close-user-data-stream-user_stream Binance API Documentation}
   */
  async deleteUserDataStream(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.deleteUserDataStream(
      requestParameters?.listenKey
    );
    return (0, import_common5.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
   * Weight: 2
   *
   * @summary Start user data stream
   * @returns {Promise<RestApiResponse<NewUserDataStreamResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof UserdatastreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/user-data-stream-endpoints#start-user-data-stream-user_stream Binance API Documentation}
   */
  async newUserDataStream() {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.newUserDataStream();
    return (0, import_common5.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
  /**
   * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.
   * Weight: 2
   *
   * @summary Keepalive user data stream
   * @param {PutUserDataStreamRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @memberof UserdatastreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/user-data-stream-endpoints#keepalive-user-data-stream-user_stream Binance API Documentation}
   */
  async putUserDataStream(requestParameters) {
    const localVarAxiosArgs = await this.localVarAxiosParamCreator.putUserDataStream(
      requestParameters?.listenKey
    );
    return (0, import_common5.sendRequest)(
      this.configuration,
      localVarAxiosArgs.endpoint,
      localVarAxiosArgs.method,
      localVarAxiosArgs.params,
      localVarAxiosArgs?.timeUnit,
      { isSigned: false }
    );
  }
};

// src/rest-api/rest-api.ts
var import_common6 = require("@binance/common");
var RestAPI = class {
  constructor(configuration) {
    this.configuration = configuration;
    this.accountApi = new AccountApi(configuration);
    this.generalApi = new GeneralApi(configuration);
    this.marketApi = new MarketApi(configuration);
    this.tradeApi = new TradeApi(configuration);
    this.userdatastreamApi = new UserdatastreamApi(configuration);
  }
  /**
   * Generic function to send a request.
   * @param endpoint - The API endpoint to call.
   * @param method - HTTP method to use (GET, POST, DELETE, etc.).
   * @param params - Query parameters for the request.
   * @param timeUnit - The time unit for the request.
   * @returns A promise resolving to the response data object.
   */
  sendRequest(endpoint, method, params = {}, timeUnit = this.configuration?.timeUnit) {
    return (0, import_common6.sendRequest)(this.configuration, endpoint, method, params, timeUnit);
  }
  /**
   * Generic function to send a signed request.
   * @param endpoint - The API endpoint to call.
   * @param method - HTTP method to use (GET, POST, DELETE, etc.).
   * @param params - Query parameters for the request.
   * @param timeUnit - The time unit for the request.
   * @returns A promise resolving to the response data object.
   */
  sendSignedRequest(endpoint, method, params = {}, timeUnit = this.configuration?.timeUnit) {
    return (0, import_common6.sendRequest)(this.configuration, endpoint, method, params, timeUnit, {
      isSigned: true
    });
  }
  /**
   * Get current account commission rates.
   * Weight: 20
   *
   * @summary Query Commission Rates
   * @param {AccountCommissionRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AccountCommissionResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-commission-rates-user_data Binance API Documentation}
   */
  accountCommission(requestParameters) {
    return this.accountApi.accountCommission(requestParameters);
  }
  /**
   * Get current account information.
   * Weight: 20
   *
   * @summary Account information
   * @param {GetAccountRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetAccountResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-information-user_data Binance API Documentation}
   */
  getAccount(requestParameters = {}) {
    return this.accountApi.getAccount(requestParameters);
  }
  /**
   * Retrieves allocations resulting from SOR order placement.
   * Weight: 20
   *
   * @summary Query Allocations
   * @param {MyAllocationsRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<MyAllocationsResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-allocations-user_data Binance API Documentation}
   */
  myAllocations(requestParameters) {
    return this.accountApi.myAllocations(requestParameters);
  }
  /**
   * Displays the list of orders that were expired due to STP.
   *
   * These are the combinations supported:
   *
   * `symbol` + `preventedMatchId`
   * `symbol` + `orderId`
   * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
   * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
   * Weight: Case                            | Weight
   * ----                            | -----
   * If `symbol` is invalid          | 2
   * Querying by `preventedMatchId`  | 2
   * Querying by `orderId`           | 20
   *
   * @summary Query Prevented Matches
   * @param {MyPreventedMatchesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<MyPreventedMatchesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-prevented-matches-user_data Binance API Documentation}
   */
  myPreventedMatches(requestParameters) {
    return this.accountApi.myPreventedMatches(requestParameters);
  }
  /**
   * Get trades for a specific account and symbol.
   * Weight: 20
   *
   * @summary Account trade list
   * @param {MyTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<MyTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-trade-list-user_data Binance API Documentation}
   */
  myTrades(requestParameters) {
    return this.accountApi.myTrades(requestParameters);
  }
  /**
   * Displays the user's unfilled order count for all intervals.
   * Weight: 40
   *
   * @summary Query Unfilled Order Count
   * @param {RateLimitOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<RateLimitOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#query-unfilled-order-count-user_data Binance API Documentation}
   */
  rateLimitOrder(requestParameters = {}) {
    return this.accountApi.rateLimitOrder(requestParameters);
  }
  /**
   * Current exchange trading rules and symbol information
   * Weight: 20
   *
   * @summary Exchange information
   * @param {ExchangeInfoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<ExchangeInfoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#exchange-information Binance API Documentation}
   */
  exchangeInfo(requestParameters) {
    return this.generalApi.exchangeInfo(requestParameters);
  }
  /**
   * Test connectivity to the Rest API.
   * Weight: 1
   *
   * @summary Test connectivity
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#test-connectivity Binance API Documentation}
   */
  ping() {
    return this.generalApi.ping();
  }
  /**
   * Test connectivity to the Rest API and get the current server time.
   * Weight: 1
   *
   * @summary Check server time
   * @returns {Promise<RestApiResponse<TimeResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#check-server-time Binance API Documentation}
   */
  time() {
    return this.generalApi.time();
  }
  /**
   * Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
   * Weight: 4
   *
   * @summary Compressed/Aggregate trades list
   * @param {AggTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AggTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#compressedaggregate-trades-list Binance API Documentation}
   */
  aggTrades(requestParameters) {
    return this.marketApi.aggTrades(requestParameters);
  }
  /**
   * Current average price for a symbol.
   * Weight: 2
   *
   * @summary Current average price
   * @param {AvgPriceRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AvgPriceResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#current-average-price Binance API Documentation}
   */
  avgPrice(requestParameters) {
    return this.marketApi.avgPrice(requestParameters);
  }
  /**
   *
   * Weight: Adjusted based on the limit:
   *
   * |Limit|Request Weight
   * ------|-------
   * 1-100|  5
   * 101-500| 25
   * 501-1000| 50
   * 1001-5000| 250
   *
   * @summary Order book
   * @param {DepthRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DepthResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#order-book Binance API Documentation}
   */
  depth(requestParameters) {
    return this.marketApi.depth(requestParameters);
  }
  /**
   * Get recent trades.
   * Weight: 25
   *
   * @summary Recent trades list
   * @param {GetTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#recent-trades-list Binance API Documentation}
   */
  getTrades(requestParameters) {
    return this.marketApi.getTrades(requestParameters);
  }
  /**
   * Get older trades.
   * Weight: 25
   *
   * @summary Old trade lookup
   * @param {HistoricalTradesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<HistoricalTradesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#old-trade-lookup Binance API Documentation}
   */
  historicalTrades(requestParameters) {
    return this.marketApi.historicalTrades(requestParameters);
  }
  /**
   * Kline/candlestick bars for a symbol.
   * Klines are uniquely identified by their open time.
   * Weight: 2
   *
   * @summary Kline/Candlestick data
   * @param {KlinesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<KlinesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#klinecandlestick-data Binance API Documentation}
   */
  klines(requestParameters) {
    return this.marketApi.klines(requestParameters);
  }
  /**
   *
   * Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
   *
   * @summary Rolling window price change statistics
   * @param {TickerRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#rolling-window-price-change-statistics Binance API Documentation}
   */
  ticker(requestParameters) {
    return this.marketApi.ticker(requestParameters);
  }
  /**
   * 24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
   * Weight: <table>
   * <thead>
   * <tr>
   * <th>Parameter</th>
   * <th>Symbols Provided</th>
   * <th>Weight</th>
   * </tr>
   * </thead>
   * <tbody>
   * <tr>
   * <td rowspan="2">symbol</td>
   * <td>1</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>symbol parameter is omitted</td>
   * <td>80</td>
   * </tr>
   * <tr>
   * <td rowspan="4">symbols</td>
   * <td>1-20</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>21-100</td>
   * <td>40</td>
   * </tr>
   * <tr>
   * <td>101 or more</td>
   * <td>80</td>
   * </tr>
   * <tr>
   * <td>symbols parameter is omitted</td>
   * <td>80</td>
   * </tr>
   * </tbody>
   * </table>
   *
   * @summary 24hr ticker price change statistics
   * @param {Ticker24hrRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<Ticker24hrResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics Binance API Documentation}
   */
  ticker24hr(requestParameters) {
    return this.marketApi.ticker24hr(requestParameters);
  }
  /**
   * Best price/qty on the order book for a symbol or symbols.
   * Weight: <table>
   * <thead>
   * <tr>
   * <th>Parameter</th>
   * <th>Symbols Provided</th>
   * <th>Weight</th>
   * </tr>
   * </thead>
   * <tbody>
   * <tr>
   * <td rowspan="2">symbol</td>
   * <td>1</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>symbol parameter is omitted</td>
   * <td>4</td>
   * </tr>
   * <tr>
   * <td>symbols</td>
   * <td>Any</td>
   * <td>4</td>
   * </tr>
   * </tbody>
   * </table>
   *
   * @summary Symbol order book ticker
   * @param {TickerBookTickerRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerBookTickerResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-order-book-ticker Binance API Documentation}
   */
  tickerBookTicker(requestParameters) {
    return this.marketApi.tickerBookTicker(requestParameters);
  }
  /**
   * Latest price for a symbol or symbols.
   * Weight: <table>
   * <thead>
   * <tr>
   * <th>Parameter</th>
   * <th>Symbols Provided</th>
   * <th>Weight</th>
   * </tr>
   * </thead>
   * <tbody>
   * <tr>
   * <td rowspan="2">symbol</td>
   * <td>1</td>
   * <td>2</td>
   * </tr>
   * <tr>
   * <td>symbol parameter is omitted</td>
   * <td>4</td>
   * </tr>
   * <tr>
   * <td>symbols</td>
   * <td>Any</td>
   * <td>4</td>
   * </tr>
   * </tbody>
   * </table>
   *
   * @summary Symbol price ticker
   * @param {TickerPriceRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerPriceResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-price-ticker Binance API Documentation}
   */
  tickerPrice(requestParameters) {
    return this.marketApi.tickerPrice(requestParameters);
  }
  /**
   * Price change statistics for a trading day.
   * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
   *
   * @summary Trading Day Ticker
   * @param {TickerTradingDayRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<TickerTradingDayResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#trading-day-ticker Binance API Documentation}
   */
  tickerTradingDay(requestParameters) {
    return this.marketApi.tickerTradingDay(requestParameters);
  }
  /**
   * The request is similar to klines having the same parameters and response.
   *
   * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
   * Weight: 2
   *
   * @summary UIKlines
   * @param {UiKlinesRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<UiKlinesResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#uiklines Binance API Documentation}
   */
  uiKlines(requestParameters) {
    return this.marketApi.uiKlines(requestParameters);
  }
  /**
   * Retrieves all order lists based on provided optional parameters.
   *
   * Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
   * Weight: 20
   *
   * @summary Query all Order lists
   * @param {AllOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AllOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-all-order-lists-user_data Binance API Documentation}
   */
  allOrderList(requestParameters = {}) {
    return this.tradeApi.allOrderList(requestParameters);
  }
  /**
   * Get all account orders; active, canceled, or filled.
   * Weight: 20
   *
   * @summary All orders
   * @param {AllOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<AllOrdersResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data Binance API Documentation}
   */
  allOrders(requestParameters) {
    return this.tradeApi.allOrders(requestParameters);
  }
  /**
   * Cancels all active orders on a symbol.
   * This includes orders that are part of an order list.
   * Weight: 1
   *
   * @summary Cancel All Open Orders on a Symbol
   * @param {DeleteOpenOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DeleteOpenOrdersResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade Binance API Documentation}
   */
  deleteOpenOrders(requestParameters) {
    return this.tradeApi.deleteOpenOrders(requestParameters);
  }
  /**
   * Cancel an active order.
   * Weight: 1
   *
   * @summary Cancel order
   * @param {DeleteOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DeleteOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade Binance API Documentation}
   */
  deleteOrder(requestParameters) {
    return this.tradeApi.deleteOrder(requestParameters);
  }
  /**
   * Cancel an entire Order list
   * Weight: 1
   *
   * @summary Cancel Order list
   * @param {DeleteOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<DeleteOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-list-trade Binance API Documentation}
   */
  deleteOrderList(requestParameters) {
    return this.tradeApi.deleteOrderList(requestParameters);
  }
  /**
   * Get all open orders on a symbol. **Careful** when accessing this with no symbol.
   * Weight: 6 for a single symbol; **80** when the symbol parameter is omitted
   *
   * @summary Current open orders
   * @param {GetOpenOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetOpenOrdersResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#current-open-orders-user_data Binance API Documentation}
   */
  getOpenOrders(requestParameters) {
    return this.tradeApi.getOpenOrders(requestParameters);
  }
  /**
   * Check an order's status.
   * Weight: 4
   *
   * @summary Query order
   * @param {GetOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-user_data Binance API Documentation}
   */
  getOrder(requestParameters) {
    return this.tradeApi.getOrder(requestParameters);
  }
  /**
   * Retrieves a specific order list based on provided optional parameters.
   * Weight: 4
   *
   * @summary Query Order list
   * @param {GetOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<GetOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-list-user_data Binance API Documentation}
   */
  getOrderList(requestParameters = {}) {
    return this.tradeApi.getOrderList(requestParameters);
  }
  /**
   * Send in a new order.
   * Weight: 1
   *
   * @summary New order
   * @param {NewOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<NewOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade Binance API Documentation}
   */
  newOrder(requestParameters) {
    return this.tradeApi.newOrder(requestParameters);
  }
  /**
   *
   * Weight: 6
   *
   * @summary Query Open Order lists
   * @param {OpenOrderListRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OpenOrderListResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-open-order-lists-user_data Binance API Documentation}
   */
  openOrderList(requestParameters = {}) {
    return this.tradeApi.openOrderList(requestParameters);
  }
  /**
   * Cancels an existing order and places a new order on the same symbol.
   *
   * Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.
   *
   * A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED` ), will still increase the order count by 1.
   * Weight: 1
   *
   * @summary Cancel an Existing Order and Send a New Order
   * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderCancelReplaceResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade Binance API Documentation}
   */
  orderCancelReplace(requestParameters) {
    return this.tradeApi.orderCancelReplace(requestParameters);
  }
  /**
   * Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.
   *
   * An OCO has 2 orders called the **above order** and **below order**.
   * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
   * Price restrictions
   * If the OCO is on the `SELL` side:
   * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
   * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * If the OCO is on the `BUY` side:
   * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
   * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and the `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New Order list - OCO
   * @param {OrderListOcoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderListOcoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade Binance API Documentation}
   */
  orderListOco(requestParameters) {
    return this.tradeApi.orderListOco(requestParameters);
  }
  /**
   * Places an OTO.
   *
   * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
   * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
   * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
   * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New Order list - OTO
   * @param {OrderListOtoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderListOtoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oto-trade Binance API Documentation}
   */
  orderListOto(requestParameters) {
    return this.tradeApi.orderListOto(requestParameters);
  }
  /**
   * Place an OTOCO.
   *
   * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
   *
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
   * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
   * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
   * OTOCOs add **3 orders** against the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New Order list - OTOCO
   * @param {OrderListOtocoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderListOtocoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---otoco-trade Binance API Documentation}
   */
  orderListOtoco(requestParameters) {
    return this.tradeApi.orderListOtoco(requestParameters);
  }
  /**
   * Send in a new OCO.
   *
   * Price Restrictions:
   * `SELL`: Limit Price > Last Price > Stop Price
   * `BUY`: Limit Price < Last Price < Stop Price
   * Quantity Restrictions:
   * Both legs must have the same quantity.
   * `ICEBERG` quantities however do not have to be the same
   * `OCO` adds **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary New OCO - Deprecated
   * @param {OrderOcoRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<OrderOcoResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-oco---deprecated-trade Binance API Documentation}
   */
  orderOco(requestParameters) {
    return this.tradeApi.orderOco(requestParameters);
  }
  /**
   * Test new order creation and signature/recvWindow long.
   * Creates and validates a new order but does not send it into the matching engine.
   * Weight: |Condition| Request Weight|
   * |------------           | ------------ |
   * |Without `computeCommissionRates`| 1|
   * |With `computeCommissionRates`|20|
   *
   * @summary Test new order
   * @param {OrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-trade Binance API Documentation}
   */
  orderTest(requestParameters = {}) {
    return this.tradeApi.orderTest(requestParameters);
  }
  /**
   * Places an order using smart order routing (SOR).
   * Weight: 1
   *
   * @summary New order using SOR
   * @param {SorOrderRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<SorOrderResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-using-sor-trade Binance API Documentation}
   */
  sorOrder(requestParameters) {
    return this.tradeApi.sorOrder(requestParameters);
  }
  /**
   * Test new order creation and signature/recvWindow using smart order routing (SOR).
   * Creates and validates a new order but does not send it into the matching engine.
   * Weight: | Condition | Request Weight |
   * | --------- | -------------- |
   * | Without `computeCommissionRates`  |  1 |
   * | With `computeCommissionRates`     | 20 |
   *
   * @summary Test new order using SOR
   * @param {SorOrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<SorOrderTestResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-using-sor-trade Binance API Documentation}
   */
  sorOrderTest(requestParameters = {}) {
    return this.tradeApi.sorOrderTest(requestParameters);
  }
  /**
   * Close out a user data stream.
   * Weight: 2
   *
   * @summary Close user data stream
   * @param {DeleteUserDataStreamRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/user-data-stream-endpoints#close-user-data-stream-user_stream Binance API Documentation}
   */
  deleteUserDataStream(requestParameters) {
    return this.userdatastreamApi.deleteUserDataStream(requestParameters);
  }
  /**
   * Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
   * Weight: 2
   *
   * @summary Start user data stream
   * @returns {Promise<RestApiResponse<NewUserDataStreamResponse>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/user-data-stream-endpoints#start-user-data-stream-user_stream Binance API Documentation}
   */
  newUserDataStream() {
    return this.userdatastreamApi.newUserDataStream();
  }
  /**
   * Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.
   * Weight: 2
   *
   * @summary Keepalive user data stream
   * @param {PutUserDataStreamRequest} requestParameters Request parameters.
   * @returns {Promise<RestApiResponse<void>>}
   * @throws {RequiredError | ConnectorClientError | UnauthorizedError | ForbiddenError | TooManyRequestsError | RateLimitBanError | ServerError | NotFoundError | NetworkError | BadRequestError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/rest-api/user-data-stream-endpoints#keepalive-user-data-stream-user_stream Binance API Documentation}
   */
  putUserDataStream(requestParameters) {
    return this.userdatastreamApi.putUserDataStream(requestParameters);
  }
};

// src/websocket-api/index.ts
var websocket_api_exports = {};
__export(websocket_api_exports, {
  AccountApi: () => AccountApi2,
  AuthApi: () => AuthApi,
  ExchangeInfoSymbolStatusEnum: () => ExchangeInfoSymbolStatusEnum2,
  GeneralApi: () => GeneralApi2,
  KlinesIntervalEnum: () => KlinesIntervalEnum2,
  MarketApi: () => MarketApi2,
  OrderCancelCancelRestrictionsEnum: () => OrderCancelCancelRestrictionsEnum,
  OrderCancelReplaceCancelReplaceModeEnum: () => OrderCancelReplaceCancelReplaceModeEnum2,
  OrderCancelReplaceCancelRestrictionsEnum: () => OrderCancelReplaceCancelRestrictionsEnum2,
  OrderCancelReplaceNewOrderRespTypeEnum: () => OrderCancelReplaceNewOrderRespTypeEnum2,
  OrderCancelReplaceOrderRateLimitExceededModeEnum: () => OrderCancelReplaceOrderRateLimitExceededModeEnum2,
  OrderCancelReplaceSelfTradePreventionModeEnum: () => OrderCancelReplaceSelfTradePreventionModeEnum2,
  OrderCancelReplaceSideEnum: () => OrderCancelReplaceSideEnum2,
  OrderCancelReplaceTimeInForceEnum: () => OrderCancelReplaceTimeInForceEnum2,
  OrderCancelReplaceTypeEnum: () => OrderCancelReplaceTypeEnum2,
  OrderListPlaceNewOrderRespTypeEnum: () => OrderListPlaceNewOrderRespTypeEnum,
  OrderListPlaceOcoAboveTypeEnum: () => OrderListPlaceOcoAboveTypeEnum,
  OrderListPlaceOcoBelowTimeInForceEnum: () => OrderListPlaceOcoBelowTimeInForceEnum,
  OrderListPlaceOcoBelowTypeEnum: () => OrderListPlaceOcoBelowTypeEnum,
  OrderListPlaceOcoNewOrderRespTypeEnum: () => OrderListPlaceOcoNewOrderRespTypeEnum,
  OrderListPlaceOcoSelfTradePreventionModeEnum: () => OrderListPlaceOcoSelfTradePreventionModeEnum,
  OrderListPlaceOcoSideEnum: () => OrderListPlaceOcoSideEnum,
  OrderListPlaceOtoNewOrderRespTypeEnum: () => OrderListPlaceOtoNewOrderRespTypeEnum,
  OrderListPlaceOtoPendingSideEnum: () => OrderListPlaceOtoPendingSideEnum,
  OrderListPlaceOtoPendingTimeInForceEnum: () => OrderListPlaceOtoPendingTimeInForceEnum,
  OrderListPlaceOtoPendingTypeEnum: () => OrderListPlaceOtoPendingTypeEnum,
  OrderListPlaceOtoSelfTradePreventionModeEnum: () => OrderListPlaceOtoSelfTradePreventionModeEnum,
  OrderListPlaceOtoWorkingSideEnum: () => OrderListPlaceOtoWorkingSideEnum,
  OrderListPlaceOtoWorkingTimeInForceEnum: () => OrderListPlaceOtoWorkingTimeInForceEnum,
  OrderListPlaceOtoWorkingTypeEnum: () => OrderListPlaceOtoWorkingTypeEnum,
  OrderListPlaceOtocoNewOrderRespTypeEnum: () => OrderListPlaceOtocoNewOrderRespTypeEnum,
  OrderListPlaceOtocoPendingAboveTimeInForceEnum: () => OrderListPlaceOtocoPendingAboveTimeInForceEnum,
  OrderListPlaceOtocoPendingAboveTypeEnum: () => OrderListPlaceOtocoPendingAboveTypeEnum,
  OrderListPlaceOtocoPendingBelowTimeInForceEnum: () => OrderListPlaceOtocoPendingBelowTimeInForceEnum,
  OrderListPlaceOtocoPendingBelowTypeEnum: () => OrderListPlaceOtocoPendingBelowTypeEnum,
  OrderListPlaceOtocoPendingSideEnum: () => OrderListPlaceOtocoPendingSideEnum,
  OrderListPlaceOtocoSelfTradePreventionModeEnum: () => OrderListPlaceOtocoSelfTradePreventionModeEnum,
  OrderListPlaceOtocoWorkingSideEnum: () => OrderListPlaceOtocoWorkingSideEnum,
  OrderListPlaceOtocoWorkingTimeInForceEnum: () => OrderListPlaceOtocoWorkingTimeInForceEnum,
  OrderListPlaceOtocoWorkingTypeEnum: () => OrderListPlaceOtocoWorkingTypeEnum,
  OrderListPlaceSelfTradePreventionModeEnum: () => OrderListPlaceSelfTradePreventionModeEnum,
  OrderListPlaceSideEnum: () => OrderListPlaceSideEnum,
  OrderListPlaceStopLimitTimeInForceEnum: () => OrderListPlaceStopLimitTimeInForceEnum,
  OrderPlaceNewOrderRespTypeEnum: () => OrderPlaceNewOrderRespTypeEnum,
  OrderPlaceSelfTradePreventionModeEnum: () => OrderPlaceSelfTradePreventionModeEnum,
  OrderPlaceSideEnum: () => OrderPlaceSideEnum,
  OrderPlaceTimeInForceEnum: () => OrderPlaceTimeInForceEnum,
  OrderPlaceTypeEnum: () => OrderPlaceTypeEnum,
  SorOrderPlaceNewOrderRespTypeEnum: () => SorOrderPlaceNewOrderRespTypeEnum,
  SorOrderPlaceSelfTradePreventionModeEnum: () => SorOrderPlaceSelfTradePreventionModeEnum,
  SorOrderPlaceSideEnum: () => SorOrderPlaceSideEnum,
  SorOrderPlaceTimeInForceEnum: () => SorOrderPlaceTimeInForceEnum,
  SorOrderPlaceTypeEnum: () => SorOrderPlaceTypeEnum,
  Ticker24hrTypeEnum: () => Ticker24hrTypeEnum2,
  TickerTradingDayTypeEnum: () => TickerTradingDayTypeEnum2,
  TickerTypeEnum: () => TickerTypeEnum2,
  TickerWindowSizeEnum: () => TickerWindowSizeEnum2,
  TradeApi: () => TradeApi2,
  UiKlinesIntervalEnum: () => UiKlinesIntervalEnum2,
  UserDataStreamApi: () => UserDataStreamApi,
  WebsocketAPI: () => WebsocketAPI,
  WebsocketAPIConnection: () => WebsocketAPIConnection
});

// src/websocket-api/modules/account-api.ts
var AccountApi2 = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
  }
  /**
   * Get current account commission rates.
   * Weight: 20
   *
   * @summary WebSocket Account Commission Rates
   * @param {AccountCommissionRequest} requestParameters Request parameters.
   * @returns {Promise<AccountCommissionResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-commission-rates-user_data Binance API Documentation}
   */
  accountCommission(requestParameters) {
    return this.websocketBase.sendMessage(
      "/account.commission".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Query your current unfilled order count for all intervals.
   * Weight: 40
   *
   * @summary WebSocket Unfilled Order Count
   * @param {AccountRateLimitsOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<AccountRateLimitsOrdersResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#unfilled-order-count-user_data Binance API Documentation}
   */
  accountRateLimitsOrders(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/account.rateLimits.orders".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Query information about your account.
   * Weight: 20
   *
   * @summary WebSocket Account information
   * @param {AccountStatusRequest} requestParameters Request parameters.
   * @returns {Promise<AccountStatusResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-information-user_data Binance API Documentation}
   */
  accountStatus(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/account.status".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Query information about all your order lists, filtered by time range.
   * Weight: 20
   *
   * @summary WebSocket Account Order list history
   * @param {AllOrderListsRequest} requestParameters Request parameters.
   * @returns {Promise<AllOrderListsResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-order-list-history-user_data Binance API Documentation}
   */
  allOrderLists(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/allOrderLists".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Query information about all your orders – active, canceled, filled – filtered by time range.
   * Weight: 20
   *
   * @summary WebSocket Account order history
   * @param {AllOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<AllOrdersResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-order-history-user_data Binance API Documentation}
   */
  allOrders(requestParameters) {
    return this.websocketBase.sendMessage(
      "/allOrders".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Retrieves allocations resulting from SOR order placement.
   * Weight: 20
   *
   * @summary WebSocket Account allocations
   * @param {MyAllocationsRequest} requestParameters Request parameters.
   * @returns {Promise<MyAllocationsResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-allocations-user_data Binance API Documentation}
   */
  myAllocations(requestParameters) {
    return this.websocketBase.sendMessage(
      "/myAllocations".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Displays the list of orders that were expired due to STP.
   *
   * These are the combinations supported:
   *
   * `symbol` + `preventedMatchId`
   * `symbol` + `orderId`
   * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
   * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
   * Weight: Case                            | Weight
   * ----                            | -----
   * If `symbol` is invalid          | 2
   * Querying by `preventedMatchId`  | 2
   * Querying by `orderId`           | 20
   *
   * @summary WebSocket Account prevented matches
   * @param {MyPreventedMatchesRequest} requestParameters Request parameters.
   * @returns {Promise<MyPreventedMatchesResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-prevented-matches-user_data Binance API Documentation}
   */
  myPreventedMatches(requestParameters) {
    return this.websocketBase.sendMessage(
      "/myPreventedMatches".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Query information about all your trades, filtered by time range.
   * Weight: 20
   *
   * @summary WebSocket Account trade history
   * @param {MyTradesRequest} requestParameters Request parameters.
   * @returns {Promise<MyTradesResponse>}
   * @memberof AccountApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-trade-history-user_data Binance API Documentation}
   */
  myTrades(requestParameters) {
    return this.websocketBase.sendMessage(
      "/myTrades".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
};

// src/websocket-api/modules/auth-api.ts
var AuthApi = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
  }
  /**
   * Authenticate WebSocket connection using the provided API key.
   *
   * After calling `session.logon`, you can omit `apiKey` and `signature` parameters for future requests that require them.
   *
   * Note that only one API key can be authenticated.
   * Calling `session.logon` multiple times changes the current authenticated API key.
   * Weight: 2
   *
   * @summary WebSocket Log in with API key
   * @param {SessionLogonRequest} requestParameters Request parameters.
   * @returns {Promise<SessionLogonResponse>}
   * @memberof AuthApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/authentication-requests#log-in-with-api-key-signed Binance API Documentation}
   */
  sessionLogon(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/session.logon".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Forget the API key previously authenticated.
   * If the connection is not authenticated, this request does nothing.
   *
   * Note that the WebSocket connection stays open after `session.logout` request.
   * You can continue using the connection,
   * but now you will have to explicitly provide the `apiKey` and `signature` parameters where needed.
   * Weight: 2
   *
   * @summary WebSocket Log out of the session
   * @param {SessionLogoutRequest} requestParameters Request parameters.
   * @returns {Promise<SessionLogoutResponse>}
   * @memberof AuthApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/authentication-requests#log-out-of-the-session Binance API Documentation}
   */
  sessionLogout(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/session.logout".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Query the status of the WebSocket connection,
   * inspecting which API key (if any) is used to authorize requests.
   * Weight: 2
   *
   * @summary WebSocket Query session status
   * @param {SessionStatusRequest} requestParameters Request parameters.
   * @returns {Promise<SessionStatusResponse>}
   * @memberof AuthApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/authentication-requests#query-session-status Binance API Documentation}
   */
  sessionStatus(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/session.status".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
};

// src/websocket-api/modules/general-api.ts
var GeneralApi2 = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
  }
  /**
   * Query current exchange trading rules, rate limits, and symbol information.
   * Weight: 20
   *
   * @summary WebSocket Exchange information
   * @param {ExchangeInfoRequest} requestParameters Request parameters.
   * @returns {Promise<ExchangeInfoResponse>}
   * @memberof GeneralApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-requests#exchange-information Binance API Documentation}
   */
  exchangeInfo(requestParameters) {
    return this.websocketBase.sendMessage(
      "/exchangeInfo".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Test connectivity to the WebSocket API.
   * Weight: 1
   *
   * @summary WebSocket Test connectivity
   * @param {PingRequest} requestParameters Request parameters.
   * @returns {Promise<void>}
   * @memberof GeneralApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-requests#test-connectivity Binance API Documentation}
   */
  ping(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/ping".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Test connectivity to the WebSocket API and get the current server time.
   * Weight: 1
   *
   * @summary WebSocket Check server time
   * @param {TimeRequest} requestParameters Request parameters.
   * @returns {Promise<TimeResponse>}
   * @memberof GeneralApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-requests#check-server-time Binance API Documentation}
   */
  time(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/time".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
};
var ExchangeInfoSymbolStatusEnum2 = {
  PRE_TRADING: "PRE_TRADING",
  TRADING: "TRADING",
  POST_TRADING: "POST_TRADING",
  END_OF_DAY: "END_OF_DAY",
  HALT: "HALT",
  AUCTION_MATCH: "AUCTION_MATCH",
  BREAK: "BREAK"
};

// src/websocket-api/modules/market-api.ts
var MarketApi2 = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
  }
  /**
   * Get current average price for a symbol.
   * Weight: 2
   *
   * @summary WebSocket Current average price
   * @param {AvgPriceRequest} requestParameters Request parameters.
   * @returns {Promise<AvgPriceResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#current-average-price Binance API Documentation}
   */
  avgPrice(requestParameters) {
    return this.websocketBase.sendMessage(
      "/avgPrice".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get current order book.
   *
   * Note that this request returns limited market depth.
   *
   * If you need to continuously monitor order book updates, please consider using WebSocket Streams:
   *
   * `<symbol>@depth<levels>`
   * `<symbol>@depth`
   *
   * You can use `depth` request together with `<symbol>@depth` streams to [maintain a local order book](web-socket-streams.md#how-to-manage-a-local-order-book-correctly).
   * Weight: Adjusted based on the limit:
   *
   * |  Limit    | Weight |
   * |:---------:|:------:|
   * |     1–100 |      5 |
   * |   101–500 |      25|
   * |  501–1000 |     50 |
   * | 1001–5000 |     250 |
   *
   * @summary WebSocket Order book
   * @param {DepthRequest} requestParameters Request parameters.
   * @returns {Promise<DepthResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#order-book Binance API Documentation}
   */
  depth(requestParameters) {
    return this.websocketBase.sendMessage(
      "/depth".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get klines (candlestick bars).
   *
   * Klines are uniquely identified by their open & close time.
   *
   * If you need access to real-time kline updates, please consider using WebSocket Streams:
   *
   * `<symbol>@kline_<interval>`
   *
   * If you need historical kline data,
   * please consider using [data.binance.vision](https://github.com/binance/binance-public-data/#klines).
   * Weight: 2
   *
   * @summary WebSocket Klines
   * @param {KlinesRequest} requestParameters Request parameters.
   * @returns {Promise<KlinesResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#klines Binance API Documentation}
   */
  klines(requestParameters) {
    return this.websocketBase.sendMessage(
      "/klines".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get rolling window price change statistics with a custom window.
   *
   * This request is similar to `ticker.24hr`,
   * but statistics are computed on demand using the arbitrary window you specify.
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Symbols | Weight |
   * |:-------:|:------:|
   * |    1–50 | 4 per symbol |
   * |  51–100 |    200 |
   *
   * @summary WebSocket Rolling window price change statistics
   * @param {TickerRequest} requestParameters Request parameters.
   * @returns {Promise<TickerResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#rolling-window-price-change-statistics Binance API Documentation}
   */
  ticker(requestParameters) {
    return this.websocketBase.sendMessage(
      "/ticker".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get 24-hour rolling window price change statistics.
   *
   * If you need to continuously monitor trading statistics, please consider using WebSocket Streams:
   *
   * `<symbol>@ticker` or `!ticker@arr`
   * `<symbol>@miniTicker` or `!miniTicker@arr`
   *
   * If you need different window sizes,
   * use the `ticker` request.
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Symbols     | Weight |
   * |:-----------:|:------:|
   * |        1–20 |      2 |
   * |      21–100 |     40 |
   * | 101 or more |     80 |
   * | all symbols |     80 |
   *
   * @summary WebSocket 24hr ticker price change statistics
   * @param {Ticker24hrRequest} requestParameters Request parameters.
   * @returns {Promise<Ticker24hrResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#24hr-ticker-price-change-statistics Binance API Documentation}
   */
  ticker24hr(requestParameters) {
    return this.websocketBase.sendMessage(
      "/ticker.24hr".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get the current best price and quantity on the order book.
   *
   * If you need access to real-time order book ticker updates, please consider using WebSocket Streams:
   *
   * `<symbol>@bookTicker`
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Parameter | Weight |
   * | --------- |:------:|
   * | `symbol`  |      2 |
   * | `symbols` |      4 |
   * | none      |      4 |
   *
   * @summary WebSocket Symbol order book ticker
   * @param {TickerBookRequest} requestParameters Request parameters.
   * @returns {Promise<TickerBookResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#symbol-order-book-ticker Binance API Documentation}
   */
  tickerBook(requestParameters) {
    return this.websocketBase.sendMessage(
      "/ticker.book".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get the latest market price for a symbol.
   *
   * If you need access to real-time price updates, please consider using WebSocket Streams:
   *
   * `<symbol>@aggTrade`
   * `<symbol>@trade`
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Parameter | Weight |
   * | --------- |:------:|
   * | `symbol`  |      2 |
   * | `symbols` |      4 |
   * | none      |      4 |
   *
   * @summary WebSocket Symbol price ticker
   * @param {TickerPriceRequest} requestParameters Request parameters.
   * @returns {Promise<TickerPriceResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#symbol-price-ticker Binance API Documentation}
   */
  tickerPrice(requestParameters) {
    return this.websocketBase.sendMessage(
      "/ticker.price".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Price change statistics for a trading day.
   * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
   *
   * @summary WebSocket Trading Day Ticker
   * @param {TickerTradingDayRequest} requestParameters Request parameters.
   * @returns {Promise<TickerTradingDayResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#trading-day-ticker Binance API Documentation}
   */
  tickerTradingDay(requestParameters) {
    return this.websocketBase.sendMessage(
      "/ticker.tradingDay".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get aggregate trades.
   *
   * An *aggregate trade* (aggtrade) represents one or more individual trades.
   * Trades that fill at the same time, from the same taker order, with the same price –
   * those trades are collected into an aggregate trade with total quantity of the individual trades.
   *
   * If you need access to real-time trading activity, please consider using WebSocket Streams:
   *
   * `<symbol>@aggTrade`
   *
   * If you need historical aggregate trade data,
   * please consider using [data.binance.vision](https://github.com/binance/binance-public-data/#aggtrades).
   * Weight: 4
   *
   * @summary WebSocket Aggregate trades
   * @param {TradesAggregateRequest} requestParameters Request parameters.
   * @returns {Promise<TradesAggregateResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#aggregate-trades Binance API Documentation}
   */
  tradesAggregate(requestParameters) {
    return this.websocketBase.sendMessage(
      "/trades.aggregate".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get historical trades.
   * Weight: 25
   *
   * @summary WebSocket Historical trades
   * @param {TradesHistoricalRequest} requestParameters Request parameters.
   * @returns {Promise<TradesHistoricalResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#historical-trades Binance API Documentation}
   */
  tradesHistorical(requestParameters) {
    return this.websocketBase.sendMessage(
      "/trades.historical".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get recent trades.
   *
   * If you need access to real-time trading activity, please consider using WebSocket Streams:
   *
   * `<symbol>@trade`
   * Weight: 25
   *
   * @summary WebSocket Recent trades
   * @param {TradesRecentRequest} requestParameters Request parameters.
   * @returns {Promise<TradesRecentResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#recent-trades Binance API Documentation}
   */
  tradesRecent(requestParameters) {
    return this.websocketBase.sendMessage(
      "/trades.recent".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
  /**
   * Get klines (candlestick bars) optimized for presentation.
   *
   * This request is similar to `klines`, having the same parameters and response.
   * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
   * Weight: 2
   *
   * @summary WebSocket UI Klines
   * @param {UiKlinesRequest} requestParameters Request parameters.
   * @returns {Promise<UiKlinesResponse>}
   * @memberof MarketApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#ui-klines Binance API Documentation}
   */
  uiKlines(requestParameters) {
    return this.websocketBase.sendMessage(
      "/uiKlines".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: false }
    );
  }
};
var KlinesIntervalEnum2 = {
  INTERVAL_1s: "1s",
  INTERVAL_1m: "1m",
  INTERVAL_3m: "3m",
  INTERVAL_5m: "5m",
  INTERVAL_15m: "15m",
  INTERVAL_30m: "30m",
  INTERVAL_1h: "1h",
  INTERVAL_2h: "2h",
  INTERVAL_4h: "4h",
  INTERVAL_6h: "6h",
  INTERVAL_8h: "8h",
  INTERVAL_12h: "12h",
  INTERVAL_1d: "1d",
  INTERVAL_3d: "3d",
  INTERVAL_1w: "1w",
  INTERVAL_1M: "1M"
};
var TickerTypeEnum2 = {
  FULL: "FULL",
  MINI: "MINI"
};
var TickerWindowSizeEnum2 = {
  WINDOW_SIZE_1m: "1m",
  WINDOW_SIZE_2m: "2m",
  WINDOW_SIZE_3m: "3m",
  WINDOW_SIZE_4m: "4m",
  WINDOW_SIZE_5m: "5m",
  WINDOW_SIZE_6m: "6m",
  WINDOW_SIZE_7m: "7m",
  WINDOW_SIZE_8m: "8m",
  WINDOW_SIZE_9m: "9m",
  WINDOW_SIZE_10m: "10m",
  WINDOW_SIZE_11m: "11m",
  WINDOW_SIZE_12m: "12m",
  WINDOW_SIZE_13m: "13m",
  WINDOW_SIZE_14m: "14m",
  WINDOW_SIZE_15m: "15m",
  WINDOW_SIZE_16m: "16m",
  WINDOW_SIZE_17m: "17m",
  WINDOW_SIZE_18m: "18m",
  WINDOW_SIZE_19m: "19m",
  WINDOW_SIZE_20m: "20m",
  WINDOW_SIZE_21m: "21m",
  WINDOW_SIZE_22m: "22m",
  WINDOW_SIZE_23m: "23m",
  WINDOW_SIZE_24m: "24m",
  WINDOW_SIZE_25m: "25m",
  WINDOW_SIZE_26m: "26m",
  WINDOW_SIZE_27m: "27m",
  WINDOW_SIZE_28m: "28m",
  WINDOW_SIZE_29m: "29m",
  WINDOW_SIZE_30m: "30m",
  WINDOW_SIZE_31m: "31m",
  WINDOW_SIZE_32m: "32m",
  WINDOW_SIZE_33m: "33m",
  WINDOW_SIZE_34m: "34m",
  WINDOW_SIZE_35m: "35m",
  WINDOW_SIZE_36m: "36m",
  WINDOW_SIZE_37m: "37m",
  WINDOW_SIZE_38m: "38m",
  WINDOW_SIZE_39m: "39m",
  WINDOW_SIZE_40m: "40m",
  WINDOW_SIZE_41m: "41m",
  WINDOW_SIZE_42m: "42m",
  WINDOW_SIZE_43m: "43m",
  WINDOW_SIZE_44m: "44m",
  WINDOW_SIZE_45m: "45m",
  WINDOW_SIZE_46m: "46m",
  WINDOW_SIZE_47m: "47m",
  WINDOW_SIZE_48m: "48m",
  WINDOW_SIZE_49m: "49m",
  WINDOW_SIZE_50m: "50m",
  WINDOW_SIZE_51m: "51m",
  WINDOW_SIZE_52m: "52m",
  WINDOW_SIZE_53m: "53m",
  WINDOW_SIZE_54m: "54m",
  WINDOW_SIZE_55m: "55m",
  WINDOW_SIZE_56m: "56m",
  WINDOW_SIZE_57m: "57m",
  WINDOW_SIZE_58m: "58m",
  WINDOW_SIZE_59m: "59m",
  WINDOW_SIZE_1h: "1h",
  WINDOW_SIZE_2h: "2h",
  WINDOW_SIZE_3h: "3h",
  WINDOW_SIZE_4h: "4h",
  WINDOW_SIZE_5h: "5h",
  WINDOW_SIZE_6h: "6h",
  WINDOW_SIZE_7h: "7h",
  WINDOW_SIZE_8h: "8h",
  WINDOW_SIZE_9h: "9h",
  WINDOW_SIZE_10h: "10h",
  WINDOW_SIZE_11h: "11h",
  WINDOW_SIZE_12h: "12h",
  WINDOW_SIZE_13h: "13h",
  WINDOW_SIZE_14h: "14h",
  WINDOW_SIZE_15h: "15h",
  WINDOW_SIZE_16h: "16h",
  WINDOW_SIZE_17h: "17h",
  WINDOW_SIZE_18h: "18h",
  WINDOW_SIZE_19h: "19h",
  WINDOW_SIZE_20h: "20h",
  WINDOW_SIZE_21h: "21h",
  WINDOW_SIZE_22h: "22h",
  WINDOW_SIZE_23h: "23h",
  WINDOW_SIZE_1d: "1d",
  WINDOW_SIZE_2d: "2d",
  WINDOW_SIZE_3d: "3d",
  WINDOW_SIZE_4d: "4d",
  WINDOW_SIZE_5d: "5d",
  WINDOW_SIZE_6d: "6d"
};
var Ticker24hrTypeEnum2 = {
  FULL: "FULL",
  MINI: "MINI"
};
var TickerTradingDayTypeEnum2 = {
  FULL: "FULL",
  MINI: "MINI"
};
var UiKlinesIntervalEnum2 = {
  INTERVAL_1s: "1s",
  INTERVAL_1m: "1m",
  INTERVAL_3m: "3m",
  INTERVAL_5m: "5m",
  INTERVAL_15m: "15m",
  INTERVAL_30m: "30m",
  INTERVAL_1h: "1h",
  INTERVAL_2h: "2h",
  INTERVAL_4h: "4h",
  INTERVAL_6h: "6h",
  INTERVAL_8h: "8h",
  INTERVAL_12h: "12h",
  INTERVAL_1d: "1d",
  INTERVAL_3d: "3d",
  INTERVAL_1w: "1w",
  INTERVAL_1M: "1M"
};

// src/websocket-api/modules/trade-api.ts
var TradeApi2 = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
  }
  /**
   * Query execution status of all open order lists.
   *
   * If you need to continuously monitor order status updates, please consider using WebSocket Streams:
   *
   * `userDataStream.start` request
   * `executionReport` user data stream event
   * Weight: 6
   *
   * @summary WebSocket Current open Order lists
   * @param {OpenOrderListsStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OpenOrderListsStatusResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#current-open-order-lists-user_data Binance API Documentation}
   */
  openOrderListsStatus(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/openOrderLists.status".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Cancel all open orders on a symbol.
   * This includes orders that are part of an order list.
   * Weight: 1
   *
   * @summary WebSocket Cancel open orders
   * @param {OpenOrdersCancelAllRequest} requestParameters Request parameters.
   * @returns {Promise<OpenOrdersCancelAllResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-open-orders-trade Binance API Documentation}
   */
  openOrdersCancelAll(requestParameters) {
    return this.websocketBase.sendMessage(
      "/openOrders.cancelAll".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Query execution status of all open orders.
   *
   * If you need to continuously monitor order status updates, please consider using WebSocket Streams:
   *
   * `userDataStream.start` request
   * `executionReport` user data stream event
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Parameter | Weight |
   * | --------- | ------ |
   * | `symbol`  |      6 |
   * | none      |     80 |
   *
   * @summary WebSocket Current open orders
   * @param {OpenOrdersStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OpenOrdersStatusResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#current-open-orders-user_data Binance API Documentation}
   */
  openOrdersStatus(requestParameters) {
    return this.websocketBase.sendMessage(
      "/openOrders.status".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Cancel an active order.
   * Weight: 1
   *
   * @summary WebSocket Cancel order
   * @param {OrderCancelRequest} requestParameters Request parameters.
   * @returns {Promise<OrderCancelResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-order-trade Binance API Documentation}
   */
  orderCancel(requestParameters) {
    return this.websocketBase.sendMessage(
      "/order.cancel".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Cancel an existing order and immediately place a new order instead of the canceled one.
   * Weight: 1
   *
   * @summary WebSocket Cancel and replace order
   * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
   * @returns {Promise<OrderCancelReplaceResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-and-replace-order-trade Binance API Documentation}
   */
  orderCancelReplace(requestParameters) {
    return this.websocketBase.sendMessage(
      "/order.cancelReplace".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Cancel an active order list.
   * Weight: 1
   *
   * @summary WebSocket Cancel Order list
   * @param {OrderListCancelRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListCancelResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-order-list-trade Binance API Documentation}
   */
  orderListCancel(requestParameters) {
    return this.websocketBase.sendMessage(
      "/orderList.cancel".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Send in a new one-cancels-the-other (OCO) pair:
   * `LIMIT_MAKER` + `STOP_LOSS`/`STOP_LOSS_LIMIT` orders (called *legs*),
   * where activation of one order immediately cancels the other.
   * Weight: 1
   *
   * @summary WebSocket Place new OCO - Deprecated
   * @param {OrderListPlaceRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-oco---deprecated-trade Binance API Documentation}
   */
  orderListPlace(requestParameters) {
    return this.websocketBase.sendMessage(
      "/orderList.place".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Send in an one-cancels the other (OCO) pair, where activation of one order immediately cancels the other.
   *
   * An OCO has 2 orders called the **above order** and **below order**.
   * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
   * Price restrictions:
   * If the OCO is on the `SELL` side:
   * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
   * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * If the OCO is on the `BUY` side:
   * `LIMIT_MAKER` `price` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
   * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
   *
   *
   * Weight: 1
   *
   * @summary WebSocket Place new Order list - OCO
   * @param {OrderListPlaceOcoRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceOcoResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-list---oco-trade Binance API Documentation}
   */
  orderListPlaceOco(requestParameters) {
    return this.websocketBase.sendMessage(
      "/orderList.place.oco".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Places an OTO.
   *
   * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
   * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
   * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary WebSocket Place new Order list - OTO
   * @param {OrderListPlaceOtoRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceOtoResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-list---oto-trade Binance API Documentation}
   */
  orderListPlaceOto(requestParameters) {
    return this.websocketBase.sendMessage(
      "/orderList.place.oto".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Place an OTOCO.
   *
   * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The behavior of the working order is the same as the [OTO](#place-new-order-list---oto-trade).
   * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
   * OTOCOs add **3 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary WebSocket Place new Order list - OTOCO
   * @param {OrderListPlaceOtocoRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceOtocoResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-list---otoco-trade Binance API Documentation}
   */
  orderListPlaceOtoco(requestParameters) {
    return this.websocketBase.sendMessage(
      "/orderList.place.otoco".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Check execution status of an Order list.
   *
   * For execution status of individual orders, use `order.status`.
   * Weight: 4
   *
   * @summary WebSocket Query Order list
   * @param {OrderListStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListStatusResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#query-order-list-user_data Binance API Documentation}
   */
  orderListStatus(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/orderList.status".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Send in a new order.
   * Weight: 1
   *
   * @summary WebSocket Place new order
   * @param {OrderPlaceRequest} requestParameters Request parameters.
   * @returns {Promise<OrderPlaceResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-trade Binance API Documentation}
   */
  orderPlace(requestParameters) {
    return this.websocketBase.sendMessage(
      "/order.place".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Check execution status of an order.
   * Weight: 4
   *
   * @summary WebSocket Query order
   * @param {OrderStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OrderStatusResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#query-order-user_data Binance API Documentation}
   */
  orderStatus(requestParameters) {
    return this.websocketBase.sendMessage(
      "/order.status".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Test order placement.
   *
   * Validates new order parameters and verifies your signature
   * but does not send the order into the matching engine.
   * Weight: |Condition| Request Weight|
   * |------------           | ------------ |
   * |Without `computeCommissionRates`| 1|
   * |With `computeCommissionRates`|20|
   *
   * @summary WebSocket Test new order
   * @param {OrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<OrderTestResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#test-new-order-trade Binance API Documentation}
   */
  orderTest(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/order.test".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Places an order using smart order routing (SOR).
   * Weight: 1
   *
   * @summary WebSocket Place new order using SOR
   * @param {SorOrderPlaceRequest} requestParameters Request parameters.
   * @returns {Promise<SorOrderPlaceResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-using-sor-trade Binance API Documentation}
   */
  sorOrderPlace(requestParameters) {
    return this.websocketBase.sendMessage(
      "/sor.order.place".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
  /**
   * Test new order creation and signature/recvWindow using smart order routing (SOR).
   * Creates and validates a new order but does not send it into the matching engine.
   * Weight: |Condition                       | Request Weight|
   * |------------                    | ------------ |
   * |Without `computeCommissionRates`| 1            |
   * |With `computeCommissionRates`   |20            |
   *
   * @summary WebSocket Test new order using SOR
   * @param {SorOrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<SorOrderTestResponse>}
   * @memberof TradeApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#test-new-order-using-sor-trade Binance API Documentation}
   */
  sorOrderTest(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/sor.order.test".slice(1),
      requestParameters,
      { isSigned: true, withApiKey: false }
    );
  }
};
var OrderCancelCancelRestrictionsEnum = {
  ONLY_NEW: "ONLY_NEW",
  NEW: "NEW",
  ONLY_PARTIALLY_FILLED: "ONLY_PARTIALLY_FILLED",
  PARTIALLY_FILLED: "PARTIALLY_FILLED"
};
var OrderCancelReplaceCancelReplaceModeEnum2 = {
  STOP_ON_FAILURE: "STOP_ON_FAILURE",
  ALLOW_FAILURE: "ALLOW_FAILURE"
};
var OrderCancelReplaceSideEnum2 = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderCancelReplaceTypeEnum2 = {
  MARKET: "MARKET",
  LIMIT: "LIMIT",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderCancelReplaceTimeInForceEnum2 = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderCancelReplaceNewOrderRespTypeEnum2 = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderCancelReplaceSelfTradePreventionModeEnum2 = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderCancelReplaceCancelRestrictionsEnum2 = {
  ONLY_NEW: "ONLY_NEW",
  NEW: "NEW",
  ONLY_PARTIALLY_FILLED: "ONLY_PARTIALLY_FILLED",
  PARTIALLY_FILLED: "PARTIALLY_FILLED"
};
var OrderCancelReplaceOrderRateLimitExceededModeEnum2 = {
  DO_NOTHING: "DO_NOTHING",
  CANCEL_ONLY: "CANCEL_ONLY"
};
var OrderListPlaceSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListPlaceStopLimitTimeInForceEnum = {
  GTC: "GTC",
  FOK: "FOK",
  IOC: "IOC"
};
var OrderListPlaceNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderListPlaceSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderListPlaceOcoSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListPlaceOcoAboveTypeEnum = {
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  STOP_LOSS: "STOP_LOSS",
  LIMIT_MAKER: "LIMIT_MAKER",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListPlaceOcoBelowTypeEnum = {
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListPlaceOcoBelowTimeInForceEnum = {
  belowType: "belowType",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListPlaceOcoNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderListPlaceOcoSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderListPlaceOtoNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderListPlaceOtoSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderListPlaceOtoWorkingTypeEnum = {
  LIMIT: "LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderListPlaceOtoWorkingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListPlaceOtoWorkingTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListPlaceOtoPendingTypeEnum = {
  LIMIT: "LIMIT",
  MARKET: "MARKET",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderListPlaceOtoPendingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListPlaceOtoPendingTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListPlaceOtocoNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderListPlaceOtocoSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var OrderListPlaceOtocoWorkingTypeEnum = {
  LIMIT: "LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderListPlaceOtocoWorkingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListPlaceOtocoWorkingTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListPlaceOtocoPendingSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderListPlaceOtocoPendingAboveTypeEnum = {
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  STOP_LOSS: "STOP_LOSS",
  LIMIT_MAKER: "LIMIT_MAKER",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListPlaceOtocoPendingAboveTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderListPlaceOtocoPendingBelowTypeEnum = {
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT"
};
var OrderListPlaceOtocoPendingBelowTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderPlaceSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var OrderPlaceTypeEnum = {
  MARKET: "MARKET",
  LIMIT: "LIMIT",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var OrderPlaceTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var OrderPlaceNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var OrderPlaceSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};
var SorOrderPlaceSideEnum = {
  BUY: "BUY",
  SELL: "SELL"
};
var SorOrderPlaceTypeEnum = {
  MARKET: "MARKET",
  LIMIT: "LIMIT",
  STOP_LOSS: "STOP_LOSS",
  STOP_LOSS_LIMIT: "STOP_LOSS_LIMIT",
  TAKE_PROFIT: "TAKE_PROFIT",
  TAKE_PROFIT_LIMIT: "TAKE_PROFIT_LIMIT",
  LIMIT_MAKER: "LIMIT_MAKER"
};
var SorOrderPlaceTimeInForceEnum = {
  GTC: "GTC",
  IOC: "IOC",
  FOK: "FOK"
};
var SorOrderPlaceNewOrderRespTypeEnum = {
  ACK: "ACK",
  RESULT: "RESULT",
  FULL: "FULL",
  MARKET: "MARKET",
  LIMIT: "LIMIT"
};
var SorOrderPlaceSelfTradePreventionModeEnum = {
  NONE: "NONE",
  EXPIRE_TAKER: "EXPIRE_TAKER",
  EXPIRE_MAKER: "EXPIRE_MAKER",
  EXPIRE_BOTH: "EXPIRE_BOTH"
};

// src/websocket-api/modules/user-data-stream-api.ts
var UserDataStreamApi = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
  }
  /**
   * Ping a user data stream to keep it alive.
   *
   * User data streams close automatically after 60 minutes,
   * even if you're listening to them on WebSocket Streams.
   * In order to keep the stream open, you have to regularly send pings using the `userDataStream.ping` request.
   *
   * It is recommended to send a ping once every 30 minutes.
   * Weight: 2
   *
   * @summary WebSocket Ping user data stream
   * @param {UserDataStreamPingRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamPingResponse>}
   * @memberof UserDataStreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#ping-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamPing(requestParameters) {
    return this.websocketBase.sendMessage(
      "/userDataStream.ping".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: true }
    );
  }
  /**
   * Start a new user data stream.
   * Weight: 2
   *
   * @summary WebSocket Start user data stream
   * @param {UserDataStreamStartRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamStartResponse>}
   * @memberof UserDataStreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#start-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamStart(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/userDataStream.start".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: true }
    );
  }
  /**
   * Explicitly stop and close the user data stream.
   * Weight: 2
   *
   * @summary WebSocket Stop user data stream
   * @param {UserDataStreamStopRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamStopResponse>}
   * @memberof UserDataStreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#stop-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamStop(requestParameters) {
    return this.websocketBase.sendMessage(
      "/userDataStream.stop".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: true }
    );
  }
  /**
   * Subscribe to the User Data Stream in the current WebSocket connection.
   * Weight: 2
   *
   * @summary WebSocket Subscribe to User Data Stream
   * @param {UserDataStreamSubscribeRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamSubscribeResponse>}
   * @memberof UserDataStreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#subscribe-to-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamSubscribe(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/userDataStream.subscribe".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: true }
    );
  }
  /**
   * Stop listening to the User Data Stream in the current WebSocket connection.
   * Weight: 2
   *
   * @summary WebSocket Unsubscribe from User Data Stream
   * @param {UserDataStreamUnsubscribeRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamUnsubscribeResponse>}
   * @memberof UserDataStreamApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#unsubscribe-from-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamUnsubscribe(requestParameters = {}) {
    return this.websocketBase.sendMessage(
      "/userDataStream.unsubscribe".slice(1),
      requestParameters,
      { isSigned: false, withApiKey: true }
    );
  }
};

// src/websocket-api/websocket-api.ts
var import_common7 = require("@binance/common");

// src/websocket-api/websocket-api-connection.ts
var WebsocketAPIConnection = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
    this.accountApi = new AccountApi2(websocketBase);
    this.authApi = new AuthApi(websocketBase);
    this.generalApi = new GeneralApi2(websocketBase);
    this.marketApi = new MarketApi2(websocketBase);
    this.tradeApi = new TradeApi2(websocketBase);
    this.userDataStreamApi = new UserDataStreamApi(websocketBase);
  }
  on(event, listener) {
    this.websocketBase.on(event, listener);
  }
  off(event, listener) {
    this.websocketBase.off(event, listener);
  }
  /**
   * Disconnects from the WebSocket server.
   * If there is no active connection, a warning is logged.
   * Otherwise, all connections in the connection pool are closed gracefully,
   * and a message is logged indicating that the connection has been disconnected.
   * @returns A Promise that resolves when all connections have been closed.
   * @throws Error if the WebSocket client is not set.
   */
  disconnect() {
    return this.websocketBase.disconnect();
  }
  /**
   * Checks if the WebSocket connection is currently open.
   * @returns `true` if the connection is open, `false` otherwise.
   */
  isConnected() {
    return this.websocketBase.isConnected();
  }
  /**
   * Sends a ping message to all connected Websocket servers in the pool.
   * If no connections are ready, a warning is logged.
   * For each active connection, the ping message is sent, and debug logs provide details.
   * @throws Error if a Websocket client is not set for a connection.
   */
  pingServer() {
    this.websocketBase.pingServer();
  }
  /**
   * Sends an unsigned message to the WebSocket server
   * @param method The API method to call
   * @param payload Message parameters and options
   * @returns Promise that resolves with the server response
   * @throws Error if not connected
   */
  sendMessage(method, payload = {}) {
    return this.websocketBase.sendMessage(method, payload);
  }
  /**
   * Sends a signed message to the WebSocket server with authentication
   * @param method The API method to call
   * @param payload Message parameters and options
   * @returns Promise that resolves with the server response
   * @throws Error if not connected
   */
  sendSignedMessage(method, payload = {}) {
    return this.websocketBase.sendMessage(method, payload, { isSigned: true });
  }
  /**
   * Get current account commission rates.
   * Weight: 20
   *
   * @summary WebSocket Account Commission Rates
   * @param {AccountCommissionRequest} requestParameters Request parameters.
   * @returns {Promise<AccountCommissionResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-commission-rates-user_data Binance API Documentation}
   */
  accountCommission(requestParameters) {
    return this.accountApi.accountCommission(requestParameters);
  }
  /**
   * Query your current unfilled order count for all intervals.
   * Weight: 40
   *
   * @summary WebSocket Unfilled Order Count
   * @param {AccountRateLimitsOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<AccountRateLimitsOrdersResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#unfilled-order-count-user_data Binance API Documentation}
   */
  accountRateLimitsOrders(requestParameters = {}) {
    return this.accountApi.accountRateLimitsOrders(requestParameters);
  }
  /**
   * Query information about your account.
   * Weight: 20
   *
   * @summary WebSocket Account information
   * @param {AccountStatusRequest} requestParameters Request parameters.
   * @returns {Promise<AccountStatusResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-information-user_data Binance API Documentation}
   */
  accountStatus(requestParameters = {}) {
    return this.accountApi.accountStatus(requestParameters);
  }
  /**
   * Query information about all your order lists, filtered by time range.
   * Weight: 20
   *
   * @summary WebSocket Account Order list history
   * @param {AllOrderListsRequest} requestParameters Request parameters.
   * @returns {Promise<AllOrderListsResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-order-list-history-user_data Binance API Documentation}
   */
  allOrderLists(requestParameters = {}) {
    return this.accountApi.allOrderLists(requestParameters);
  }
  /**
   * Query information about all your orders – active, canceled, filled – filtered by time range.
   * Weight: 20
   *
   * @summary WebSocket Account order history
   * @param {AllOrdersRequest} requestParameters Request parameters.
   * @returns {Promise<AllOrdersResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-order-history-user_data Binance API Documentation}
   */
  allOrders(requestParameters) {
    return this.accountApi.allOrders(requestParameters);
  }
  /**
   * Retrieves allocations resulting from SOR order placement.
   * Weight: 20
   *
   * @summary WebSocket Account allocations
   * @param {MyAllocationsRequest} requestParameters Request parameters.
   * @returns {Promise<MyAllocationsResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-allocations-user_data Binance API Documentation}
   */
  myAllocations(requestParameters) {
    return this.accountApi.myAllocations(requestParameters);
  }
  /**
   * Displays the list of orders that were expired due to STP.
   *
   * These are the combinations supported:
   *
   * `symbol` + `preventedMatchId`
   * `symbol` + `orderId`
   * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
   * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
   * Weight: Case                            | Weight
   * ----                            | -----
   * If `symbol` is invalid          | 2
   * Querying by `preventedMatchId`  | 2
   * Querying by `orderId`           | 20
   *
   * @summary WebSocket Account prevented matches
   * @param {MyPreventedMatchesRequest} requestParameters Request parameters.
   * @returns {Promise<MyPreventedMatchesResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-prevented-matches-user_data Binance API Documentation}
   */
  myPreventedMatches(requestParameters) {
    return this.accountApi.myPreventedMatches(requestParameters);
  }
  /**
   * Query information about all your trades, filtered by time range.
   * Weight: 20
   *
   * @summary WebSocket Account trade history
   * @param {MyTradesRequest} requestParameters Request parameters.
   * @returns {Promise<MyTradesResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/account-requests#account-trade-history-user_data Binance API Documentation}
   */
  myTrades(requestParameters) {
    return this.accountApi.myTrades(requestParameters);
  }
  /**
   * Authenticate WebSocket connection using the provided API key.
   *
   * After calling `session.logon`, you can omit `apiKey` and `signature` parameters for future requests that require them.
   *
   * Note that only one API key can be authenticated.
   * Calling `session.logon` multiple times changes the current authenticated API key.
   * Weight: 2
   *
   * @summary WebSocket Log in with API key
   * @param {SessionLogonRequest} requestParameters Request parameters.
   * @returns {Promise<SessionLogonResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/authentication-requests#log-in-with-api-key-signed Binance API Documentation}
   */
  sessionLogon(requestParameters = {}) {
    return this.authApi.sessionLogon(requestParameters);
  }
  /**
   * Forget the API key previously authenticated.
   * If the connection is not authenticated, this request does nothing.
   *
   * Note that the WebSocket connection stays open after `session.logout` request.
   * You can continue using the connection,
   * but now you will have to explicitly provide the `apiKey` and `signature` parameters where needed.
   * Weight: 2
   *
   * @summary WebSocket Log out of the session
   * @param {SessionLogoutRequest} requestParameters Request parameters.
   * @returns {Promise<SessionLogoutResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/authentication-requests#log-out-of-the-session Binance API Documentation}
   */
  sessionLogout(requestParameters = {}) {
    return this.authApi.sessionLogout(requestParameters);
  }
  /**
   * Query the status of the WebSocket connection,
   * inspecting which API key (if any) is used to authorize requests.
   * Weight: 2
   *
   * @summary WebSocket Query session status
   * @param {SessionStatusRequest} requestParameters Request parameters.
   * @returns {Promise<SessionStatusResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/authentication-requests#query-session-status Binance API Documentation}
   */
  sessionStatus(requestParameters = {}) {
    return this.authApi.sessionStatus(requestParameters);
  }
  /**
   * Query current exchange trading rules, rate limits, and symbol information.
   * Weight: 20
   *
   * @summary WebSocket Exchange information
   * @param {ExchangeInfoRequest} requestParameters Request parameters.
   * @returns {Promise<ExchangeInfoResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-requests#exchange-information Binance API Documentation}
   */
  exchangeInfo(requestParameters) {
    return this.generalApi.exchangeInfo(requestParameters);
  }
  /**
   * Test connectivity to the WebSocket API.
   * Weight: 1
   *
   * @summary WebSocket Test connectivity
   * @param {PingRequest} requestParameters Request parameters.
   * @returns {Promise<void>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-requests#test-connectivity Binance API Documentation}
   */
  ping(requestParameters = {}) {
    return this.generalApi.ping(requestParameters);
  }
  /**
   * Test connectivity to the WebSocket API and get the current server time.
   * Weight: 1
   *
   * @summary WebSocket Check server time
   * @param {TimeRequest} requestParameters Request parameters.
   * @returns {Promise<TimeResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-requests#check-server-time Binance API Documentation}
   */
  time(requestParameters = {}) {
    return this.generalApi.time(requestParameters);
  }
  /**
   * Get current average price for a symbol.
   * Weight: 2
   *
   * @summary WebSocket Current average price
   * @param {AvgPriceRequest} requestParameters Request parameters.
   * @returns {Promise<AvgPriceResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#current-average-price Binance API Documentation}
   */
  avgPrice(requestParameters) {
    return this.marketApi.avgPrice(requestParameters);
  }
  /**
   * Get current order book.
   *
   * Note that this request returns limited market depth.
   *
   * If you need to continuously monitor order book updates, please consider using WebSocket Streams:
   *
   * `<symbol>@depth<levels>`
   * `<symbol>@depth`
   *
   * You can use `depth` request together with `<symbol>@depth` streams to [maintain a local order book](web-socket-streams.md#how-to-manage-a-local-order-book-correctly).
   * Weight: Adjusted based on the limit:
   *
   * |  Limit    | Weight |
   * |:---------:|:------:|
   * |     1–100 |      5 |
   * |   101–500 |      25|
   * |  501–1000 |     50 |
   * | 1001–5000 |     250 |
   *
   * @summary WebSocket Order book
   * @param {DepthRequest} requestParameters Request parameters.
   * @returns {Promise<DepthResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#order-book Binance API Documentation}
   */
  depth(requestParameters) {
    return this.marketApi.depth(requestParameters);
  }
  /**
   * Get klines (candlestick bars).
   *
   * Klines are uniquely identified by their open & close time.
   *
   * If you need access to real-time kline updates, please consider using WebSocket Streams:
   *
   * `<symbol>@kline_<interval>`
   *
   * If you need historical kline data,
   * please consider using [data.binance.vision](https://github.com/binance/binance-public-data/#klines).
   * Weight: 2
   *
   * @summary WebSocket Klines
   * @param {KlinesRequest} requestParameters Request parameters.
   * @returns {Promise<KlinesResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#klines Binance API Documentation}
   */
  klines(requestParameters) {
    return this.marketApi.klines(requestParameters);
  }
  /**
   * Get rolling window price change statistics with a custom window.
   *
   * This request is similar to `ticker.24hr`,
   * but statistics are computed on demand using the arbitrary window you specify.
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Symbols | Weight |
   * |:-------:|:------:|
   * |    1–50 | 4 per symbol |
   * |  51–100 |    200 |
   *
   * @summary WebSocket Rolling window price change statistics
   * @param {TickerRequest} requestParameters Request parameters.
   * @returns {Promise<TickerResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#rolling-window-price-change-statistics Binance API Documentation}
   */
  ticker(requestParameters) {
    return this.marketApi.ticker(requestParameters);
  }
  /**
   * Get 24-hour rolling window price change statistics.
   *
   * If you need to continuously monitor trading statistics, please consider using WebSocket Streams:
   *
   * `<symbol>@ticker` or `!ticker@arr`
   * `<symbol>@miniTicker` or `!miniTicker@arr`
   *
   * If you need different window sizes,
   * use the `ticker` request.
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Symbols     | Weight |
   * |:-----------:|:------:|
   * |        1–20 |      2 |
   * |      21–100 |     40 |
   * | 101 or more |     80 |
   * | all symbols |     80 |
   *
   * @summary WebSocket 24hr ticker price change statistics
   * @param {Ticker24hrRequest} requestParameters Request parameters.
   * @returns {Promise<Ticker24hrResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#24hr-ticker-price-change-statistics Binance API Documentation}
   */
  ticker24hr(requestParameters) {
    return this.marketApi.ticker24hr(requestParameters);
  }
  /**
   * Get the current best price and quantity on the order book.
   *
   * If you need access to real-time order book ticker updates, please consider using WebSocket Streams:
   *
   * `<symbol>@bookTicker`
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Parameter | Weight |
   * | --------- |:------:|
   * | `symbol`  |      2 |
   * | `symbols` |      4 |
   * | none      |      4 |
   *
   * @summary WebSocket Symbol order book ticker
   * @param {TickerBookRequest} requestParameters Request parameters.
   * @returns {Promise<TickerBookResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#symbol-order-book-ticker Binance API Documentation}
   */
  tickerBook(requestParameters) {
    return this.marketApi.tickerBook(requestParameters);
  }
  /**
   * Get the latest market price for a symbol.
   *
   * If you need access to real-time price updates, please consider using WebSocket Streams:
   *
   * `<symbol>@aggTrade`
   * `<symbol>@trade`
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Parameter | Weight |
   * | --------- |:------:|
   * | `symbol`  |      2 |
   * | `symbols` |      4 |
   * | none      |      4 |
   *
   * @summary WebSocket Symbol price ticker
   * @param {TickerPriceRequest} requestParameters Request parameters.
   * @returns {Promise<TickerPriceResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#symbol-price-ticker Binance API Documentation}
   */
  tickerPrice(requestParameters) {
    return this.marketApi.tickerPrice(requestParameters);
  }
  /**
   * Price change statistics for a trading day.
   * Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.
   *
   * @summary WebSocket Trading Day Ticker
   * @param {TickerTradingDayRequest} requestParameters Request parameters.
   * @returns {Promise<TickerTradingDayResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#trading-day-ticker Binance API Documentation}
   */
  tickerTradingDay(requestParameters) {
    return this.marketApi.tickerTradingDay(requestParameters);
  }
  /**
   * Get aggregate trades.
   *
   * An *aggregate trade* (aggtrade) represents one or more individual trades.
   * Trades that fill at the same time, from the same taker order, with the same price –
   * those trades are collected into an aggregate trade with total quantity of the individual trades.
   *
   * If you need access to real-time trading activity, please consider using WebSocket Streams:
   *
   * `<symbol>@aggTrade`
   *
   * If you need historical aggregate trade data,
   * please consider using [data.binance.vision](https://github.com/binance/binance-public-data/#aggtrades).
   * Weight: 4
   *
   * @summary WebSocket Aggregate trades
   * @param {TradesAggregateRequest} requestParameters Request parameters.
   * @returns {Promise<TradesAggregateResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#aggregate-trades Binance API Documentation}
   */
  tradesAggregate(requestParameters) {
    return this.marketApi.tradesAggregate(requestParameters);
  }
  /**
   * Get historical trades.
   * Weight: 25
   *
   * @summary WebSocket Historical trades
   * @param {TradesHistoricalRequest} requestParameters Request parameters.
   * @returns {Promise<TradesHistoricalResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#historical-trades Binance API Documentation}
   */
  tradesHistorical(requestParameters) {
    return this.marketApi.tradesHistorical(requestParameters);
  }
  /**
   * Get recent trades.
   *
   * If you need access to real-time trading activity, please consider using WebSocket Streams:
   *
   * `<symbol>@trade`
   * Weight: 25
   *
   * @summary WebSocket Recent trades
   * @param {TradesRecentRequest} requestParameters Request parameters.
   * @returns {Promise<TradesRecentResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#recent-trades Binance API Documentation}
   */
  tradesRecent(requestParameters) {
    return this.marketApi.tradesRecent(requestParameters);
  }
  /**
   * Get klines (candlestick bars) optimized for presentation.
   *
   * This request is similar to `klines`, having the same parameters and response.
   * `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
   * Weight: 2
   *
   * @summary WebSocket UI Klines
   * @param {UiKlinesRequest} requestParameters Request parameters.
   * @returns {Promise<UiKlinesResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/market-data-requests#ui-klines Binance API Documentation}
   */
  uiKlines(requestParameters) {
    return this.marketApi.uiKlines(requestParameters);
  }
  /**
   * Query execution status of all open order lists.
   *
   * If you need to continuously monitor order status updates, please consider using WebSocket Streams:
   *
   * `userDataStream.start` request
   * `executionReport` user data stream event
   * Weight: 6
   *
   * @summary WebSocket Current open Order lists
   * @param {OpenOrderListsStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OpenOrderListsStatusResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#current-open-order-lists-user_data Binance API Documentation}
   */
  openOrderListsStatus(requestParameters = {}) {
    return this.tradeApi.openOrderListsStatus(requestParameters);
  }
  /**
   * Cancel all open orders on a symbol.
   * This includes orders that are part of an order list.
   * Weight: 1
   *
   * @summary WebSocket Cancel open orders
   * @param {OpenOrdersCancelAllRequest} requestParameters Request parameters.
   * @returns {Promise<OpenOrdersCancelAllResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-open-orders-trade Binance API Documentation}
   */
  openOrdersCancelAll(requestParameters) {
    return this.tradeApi.openOrdersCancelAll(requestParameters);
  }
  /**
   * Query execution status of all open orders.
   *
   * If you need to continuously monitor order status updates, please consider using WebSocket Streams:
   *
   * `userDataStream.start` request
   * `executionReport` user data stream event
   * Weight: Adjusted based on the number of requested symbols:
   *
   * | Parameter | Weight |
   * | --------- | ------ |
   * | `symbol`  |      6 |
   * | none      |     80 |
   *
   * @summary WebSocket Current open orders
   * @param {OpenOrdersStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OpenOrdersStatusResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#current-open-orders-user_data Binance API Documentation}
   */
  openOrdersStatus(requestParameters) {
    return this.tradeApi.openOrdersStatus(requestParameters);
  }
  /**
   * Cancel an active order.
   * Weight: 1
   *
   * @summary WebSocket Cancel order
   * @param {OrderCancelRequest} requestParameters Request parameters.
   * @returns {Promise<OrderCancelResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-order-trade Binance API Documentation}
   */
  orderCancel(requestParameters) {
    return this.tradeApi.orderCancel(requestParameters);
  }
  /**
   * Cancel an existing order and immediately place a new order instead of the canceled one.
   * Weight: 1
   *
   * @summary WebSocket Cancel and replace order
   * @param {OrderCancelReplaceRequest} requestParameters Request parameters.
   * @returns {Promise<OrderCancelReplaceResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-and-replace-order-trade Binance API Documentation}
   */
  orderCancelReplace(requestParameters) {
    return this.tradeApi.orderCancelReplace(requestParameters);
  }
  /**
   * Cancel an active order list.
   * Weight: 1
   *
   * @summary WebSocket Cancel Order list
   * @param {OrderListCancelRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListCancelResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#cancel-order-list-trade Binance API Documentation}
   */
  orderListCancel(requestParameters) {
    return this.tradeApi.orderListCancel(requestParameters);
  }
  /**
   * Send in a new one-cancels-the-other (OCO) pair:
   * `LIMIT_MAKER` + `STOP_LOSS`/`STOP_LOSS_LIMIT` orders (called *legs*),
   * where activation of one order immediately cancels the other.
   * Weight: 1
   *
   * @summary WebSocket Place new OCO - Deprecated
   * @param {OrderListPlaceRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-oco---deprecated-trade Binance API Documentation}
   */
  orderListPlace(requestParameters) {
    return this.tradeApi.orderListPlace(requestParameters);
  }
  /**
   * Send in an one-cancels the other (OCO) pair, where activation of one order immediately cancels the other.
   *
   * An OCO has 2 orders called the **above order** and **below order**.
   * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
   * Price restrictions:
   * If the OCO is on the `SELL` side:
   * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
   * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * If the OCO is on the `BUY` side:
   * `LIMIT_MAKER` `price` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
   * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
   * OCOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
   *
   *
   * Weight: 1
   *
   * @summary WebSocket Place new Order list - OCO
   * @param {OrderListPlaceOcoRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceOcoResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-list---oco-trade Binance API Documentation}
   */
  orderListPlaceOco(requestParameters) {
    return this.tradeApi.orderListPlaceOco(requestParameters);
  }
  /**
   * Places an OTO.
   *
   * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
   * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
   * OTOs add **2 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary WebSocket Place new Order list - OTO
   * @param {OrderListPlaceOtoRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceOtoResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-list---oto-trade Binance API Documentation}
   */
  orderListPlaceOto(requestParameters) {
    return this.tradeApi.orderListPlaceOto(requestParameters);
  }
  /**
   * Place an OTOCO.
   *
   * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
   * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
   * The behavior of the working order is the same as the [OTO](#place-new-order-list---oto-trade).
   * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
   * OTOCOs add **3 orders** to the unfilled order count, `EXCHANGE_MAX_NUM_ORDERS` filter, and `MAX_NUM_ORDERS` filter.
   * Weight: 1
   *
   * @summary WebSocket Place new Order list - OTOCO
   * @param {OrderListPlaceOtocoRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListPlaceOtocoResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-list---otoco-trade Binance API Documentation}
   */
  orderListPlaceOtoco(requestParameters) {
    return this.tradeApi.orderListPlaceOtoco(requestParameters);
  }
  /**
   * Check execution status of an Order list.
   *
   * For execution status of individual orders, use `order.status`.
   * Weight: 4
   *
   * @summary WebSocket Query Order list
   * @param {OrderListStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OrderListStatusResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#query-order-list-user_data Binance API Documentation}
   */
  orderListStatus(requestParameters = {}) {
    return this.tradeApi.orderListStatus(requestParameters);
  }
  /**
   * Send in a new order.
   * Weight: 1
   *
   * @summary WebSocket Place new order
   * @param {OrderPlaceRequest} requestParameters Request parameters.
   * @returns {Promise<OrderPlaceResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-trade Binance API Documentation}
   */
  orderPlace(requestParameters) {
    return this.tradeApi.orderPlace(requestParameters);
  }
  /**
   * Check execution status of an order.
   * Weight: 4
   *
   * @summary WebSocket Query order
   * @param {OrderStatusRequest} requestParameters Request parameters.
   * @returns {Promise<OrderStatusResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#query-order-user_data Binance API Documentation}
   */
  orderStatus(requestParameters) {
    return this.tradeApi.orderStatus(requestParameters);
  }
  /**
   * Test order placement.
   *
   * Validates new order parameters and verifies your signature
   * but does not send the order into the matching engine.
   * Weight: |Condition| Request Weight|
   * |------------           | ------------ |
   * |Without `computeCommissionRates`| 1|
   * |With `computeCommissionRates`|20|
   *
   * @summary WebSocket Test new order
   * @param {OrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<OrderTestResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#test-new-order-trade Binance API Documentation}
   */
  orderTest(requestParameters = {}) {
    return this.tradeApi.orderTest(requestParameters);
  }
  /**
   * Places an order using smart order routing (SOR).
   * Weight: 1
   *
   * @summary WebSocket Place new order using SOR
   * @param {SorOrderPlaceRequest} requestParameters Request parameters.
   * @returns {Promise<SorOrderPlaceResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#place-new-order-using-sor-trade Binance API Documentation}
   */
  sorOrderPlace(requestParameters) {
    return this.tradeApi.sorOrderPlace(requestParameters);
  }
  /**
   * Test new order creation and signature/recvWindow using smart order routing (SOR).
   * Creates and validates a new order but does not send it into the matching engine.
   * Weight: |Condition                       | Request Weight|
   * |------------                    | ------------ |
   * |Without `computeCommissionRates`| 1            |
   * |With `computeCommissionRates`   |20            |
   *
   * @summary WebSocket Test new order using SOR
   * @param {SorOrderTestRequest} requestParameters Request parameters.
   * @returns {Promise<SorOrderTestResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/trading-requests#test-new-order-using-sor-trade Binance API Documentation}
   */
  sorOrderTest(requestParameters = {}) {
    return this.tradeApi.sorOrderTest(requestParameters);
  }
  /**
   * Ping a user data stream to keep it alive.
   *
   * User data streams close automatically after 60 minutes,
   * even if you're listening to them on WebSocket Streams.
   * In order to keep the stream open, you have to regularly send pings using the `userDataStream.ping` request.
   *
   * It is recommended to send a ping once every 30 minutes.
   * Weight: 2
   *
   * @summary WebSocket Ping user data stream
   * @param {UserDataStreamPingRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamPingResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#ping-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamPing(requestParameters) {
    return this.userDataStreamApi.userDataStreamPing(requestParameters);
  }
  /**
   * Start a new user data stream.
   * Weight: 2
   *
   * @summary WebSocket Start user data stream
   * @param {UserDataStreamStartRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamStartResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#start-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamStart(requestParameters = {}) {
    return this.userDataStreamApi.userDataStreamStart(requestParameters);
  }
  /**
   * Explicitly stop and close the user data stream.
   * Weight: 2
   *
   * @summary WebSocket Stop user data stream
   * @param {UserDataStreamStopRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamStopResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#stop-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamStop(requestParameters) {
    return this.userDataStreamApi.userDataStreamStop(requestParameters);
  }
  /**
   * Subscribe to the User Data Stream in the current WebSocket connection.
   * Weight: 2
   *
   * @summary WebSocket Subscribe to User Data Stream
   * @param {UserDataStreamSubscribeRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamSubscribeResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#subscribe-to-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamSubscribe(requestParameters = {}) {
    return this.userDataStreamApi.userDataStreamSubscribe(requestParameters);
  }
  /**
   * Stop listening to the User Data Stream in the current WebSocket connection.
   * Weight: 2
   *
   * @summary WebSocket Unsubscribe from User Data Stream
   * @param {UserDataStreamUnsubscribeRequest} requestParameters Request parameters.
   * @returns {Promise<UserDataStreamUnsubscribeResponse>}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/user-Data-Stream-requests#unsubscribe-from-user-data-stream-user_stream Binance API Documentation}
   */
  userDataStreamUnsubscribe(requestParameters = {}) {
    return this.userDataStreamApi.userDataStreamUnsubscribe(requestParameters);
  }
};

// src/websocket-api/websocket-api.ts
var WebsocketAPI = class {
  constructor(configuration) {
    this.configuration = configuration;
  }
  /**
   * Connects to the Binance WebSocket API and returns a `WebsocketAPIConnection` instance.
   *
   * @param {object} [options] - Optional connection options.
   * @param {string} [options.mode='single'] - The connection mode, either 'single' or 'pool'. Overrides the `mode` property in the configuration.
   * @param {number} [options.poolSize=1] - The number of connections to use in pool mode. Overrides the `poolSize` property in the configuration.
   * @returns {Promise<WebsocketAPIConnection>} - A promise that resolves to a `WebsocketAPIConnection` instance.
   */
  async connect({
    mode,
    poolSize
  } = {}) {
    const websocketBase = new import_common7.WebsocketAPIBase({
      ...this.configuration,
      ...mode && { mode },
      ...poolSize && { poolSize }
    });
    const websocketAPIConnection = new WebsocketAPIConnection(websocketBase);
    await websocketBase.connect();
    return websocketAPIConnection;
  }
};

// src/websocket-streams/index.ts
var websocket_streams_exports = {};
__export(websocket_streams_exports, {
  AllMarketRollingWindowTickerWindowSizeEnum: () => AllMarketRollingWindowTickerWindowSizeEnum,
  KlineIntervalEnum: () => KlineIntervalEnum,
  KlineOffsetIntervalEnum: () => KlineOffsetIntervalEnum,
  PartialBookDepthLevelsEnum: () => PartialBookDepthLevelsEnum,
  RollingWindowTickerWindowSizeEnum: () => RollingWindowTickerWindowSizeEnum,
  WebSocketStreamsApi: () => WebSocketStreamsApi,
  WebsocketStreams: () => WebsocketStreams,
  WebsocketStreamsConnection: () => WebsocketStreamsConnection
});

// src/websocket-streams/modules/web-socket-streams-api.ts
var import_common8 = require("@binance/common");
var WebSocketStreamsApiParamCreator = function() {
  return {
    /**
     * The Aggregate Trade Streams push trade information that is aggregated for a single taker order.
     *
     * @summary WebSocket Aggregate Trade Streams
     * @param {string} symbol Symbol to query
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    aggTrade: (symbol, id) => {
      (0, import_common8.assertParamExists)("aggTrade", "symbol", symbol);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@aggTrade".slice(1), {
        symbol,
        id
      });
    },
    /**
     * Rolling window ticker statistics for all market symbols, computed over multiple windows.
     * Note that only tickers that have changed will be present in the array.
     *
     * @summary WebSocket All Market Rolling Window Statistics Streams
     * @param {AllMarketRollingWindowTickerWindowSizeEnum} windowSize
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    allMarketRollingWindowTicker: (windowSize, id) => {
      (0, import_common8.assertParamExists)("allMarketRollingWindowTicker", "windowSize", windowSize);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/!ticker_<window-size>@arr".slice(1), {
        windowSize,
        id
      });
    },
    /**
     * 24hr rolling window mini-ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.
     *
     * @summary WebSocket All Market Mini Tickers Stream
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    allMiniTicker: (id) => {
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/!miniTicker@arr".slice(1), { id });
    },
    /**
     * 24hr rolling window ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.
     *
     * @summary WebSocket All Market Tickers Stream
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    allTicker: (id) => {
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/!ticker@arr".slice(1), { id });
    },
    /**
     * Average price streams push changes in the average price over a fixed time interval.
     *
     * @summary WebSocket Average Price
     * @param {string} symbol Symbol to query
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    avgPrice: (symbol, id) => {
      (0, import_common8.assertParamExists)("avgPrice", "symbol", symbol);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@avgPrice".slice(1), {
        symbol,
        id
      });
    },
    /**
     * Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
     * Multiple `<symbol>@bookTicker` streams can be subscribed to over one connection.
     *
     * @summary WebSocket Individual Symbol Book Ticker Streams
     * @param {string} symbol Symbol to query
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    bookTicker: (symbol, id) => {
      (0, import_common8.assertParamExists)("bookTicker", "symbol", symbol);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@bookTicker".slice(1), {
        symbol,
        id
      });
    },
    /**
     * Order book price and quantity depth updates used to locally manage an order book.
     *
     * @summary WebSocket Diff. Depth Stream
     * @param {string} symbol Symbol to query
     * @param {string} [id] Unique WebSocket request ID.
     * @param {string} [updateSpeed] 1000ms or 100ms
     *
     * @throws {RequiredError}
     */
    diffBookDepth: (symbol, id, updateSpeed) => {
      (0, import_common8.assertParamExists)("diffBookDepth", "symbol", symbol);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@depth<updateSpeed>".slice(1), {
        symbol,
        id,
        updateSpeed
      });
    },
    /**
     * The Kline/Candlestick Stream push updates to the current klines/candlestick every second in `UTC+0` timezone
     *
     * <a id="kline-intervals"></a>
     *
     * @summary WebSocket Kline/Candlestick Streams for UTC
     * @param {string} symbol Symbol to query
     * @param {KlineIntervalEnum} interval
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    kline: (symbol, interval, id) => {
      (0, import_common8.assertParamExists)("kline", "symbol", symbol);
      (0, import_common8.assertParamExists)("kline", "interval", interval);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@kline_<interval>".slice(1), {
        symbol,
        interval,
        id
      });
    },
    /**
     * The Kline/Candlestick Stream push updates to the current klines/candlestick every second in `UTC+8` timezone
     *
     * @summary WebSocket Kline/Candlestick Streams with timezone offset
     * @param {string} symbol Symbol to query
     * @param {KlineOffsetIntervalEnum} interval
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    klineOffset: (symbol, interval, id) => {
      (0, import_common8.assertParamExists)("klineOffset", "symbol", symbol);
      (0, import_common8.assertParamExists)("klineOffset", "interval", interval);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)(
        "/<symbol>@kline_<interval>@+08:00".slice(1),
        { symbol, interval, id }
      );
    },
    /**
     * 24hr rolling window mini-ticker statistics. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
     *
     * @summary WebSocket Individual Symbol Mini Ticker Stream
     * @param {string} symbol Symbol to query
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    miniTicker: (symbol, id) => {
      (0, import_common8.assertParamExists)("miniTicker", "symbol", symbol);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@miniTicker".slice(1), {
        symbol,
        id
      });
    },
    /**
     * Top **\<levels\>** bids and asks, pushed every second. Valid **\<levels\>** are 5, 10, or 20.
     *
     * @summary WebSocket Partial Book Depth Streams
     * @param {string} symbol Symbol to query
     * @param {PartialBookDepthLevelsEnum} levels
     * @param {string} [id] Unique WebSocket request ID.
     * @param {string} [updateSpeed] 1000ms or 100ms
     *
     * @throws {RequiredError}
     */
    partialBookDepth: (symbol, levels, id, updateSpeed) => {
      (0, import_common8.assertParamExists)("partialBookDepth", "symbol", symbol);
      (0, import_common8.assertParamExists)("partialBookDepth", "levels", levels);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)(
        "/<symbol>@depth<levels><updateSpeed>".slice(1),
        { symbol, levels, id, updateSpeed }
      );
    },
    /**
     * Rolling window ticker statistics for a single symbol, computed over multiple windows.
     *
     * @summary WebSocket Individual Symbol Rolling Window Statistics Streams
     * @param {string} symbol Symbol to query
     * @param {RollingWindowTickerWindowSizeEnum} windowSize
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    rollingWindowTicker: (symbol, windowSize, id) => {
      (0, import_common8.assertParamExists)("rollingWindowTicker", "symbol", symbol);
      (0, import_common8.assertParamExists)("rollingWindowTicker", "windowSize", windowSize);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@ticker_<window_size>".slice(1), {
        symbol,
        windowSize,
        id
      });
    },
    /**
     * 24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
     *
     * @summary WebSocket Individual Symbol Ticker Streams
     * @param {string} symbol Symbol to query
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    ticker: (symbol, id) => {
      (0, import_common8.assertParamExists)("ticker", "symbol", symbol);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@ticker".slice(1), { symbol, id });
    },
    /**
     * The Trade Streams push raw trade information; each trade has a unique buyer and seller.
     *
     * @summary WebSocket Trade Streams
     * @param {string} symbol Symbol to query
     * @param {string} [id] Unique WebSocket request ID.
     *
     * @throws {RequiredError}
     */
    trade: (symbol, id) => {
      (0, import_common8.assertParamExists)("trade", "symbol", symbol);
      return (0, import_common8.replaceWebsocketStreamsPlaceholders)("/<symbol>@trade".slice(1), { symbol, id });
    }
  };
};
var WebSocketStreamsApi = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
    this.localVarParamCreator = WebSocketStreamsApiParamCreator();
  }
  /**
   * The Aggregate Trade Streams push trade information that is aggregated for a single taker order.
   *
   * @summary WebSocket Aggregate Trade Streams
   * @param {AggTradeRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AggTradeResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#aggregate-trade-streams Binance API Documentation}
   */
  aggTrade(requestParameters) {
    const stream = this.localVarParamCreator.aggTrade(
      requestParameters?.symbol,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * Rolling window ticker statistics for all market symbols, computed over multiple windows.
   * Note that only tickers that have changed will be present in the array.
   *
   * @summary WebSocket All Market Rolling Window Statistics Streams
   * @param {AllMarketRollingWindowTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AllMarketRollingWindowTickerResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-rolling-window-statistics-streams Binance API Documentation}
   */
  allMarketRollingWindowTicker(requestParameters) {
    const stream = this.localVarParamCreator.allMarketRollingWindowTicker(
      requestParameters?.windowSize,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * 24hr rolling window mini-ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.
   *
   * @summary WebSocket All Market Mini Tickers Stream
   * @param {AllMiniTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AllMiniTickerResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream Binance API Documentation}
   */
  allMiniTicker(requestParameters = {}) {
    const stream = this.localVarParamCreator.allMiniTicker(requestParameters?.id);
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * 24hr rolling window ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.
   *
   * @summary WebSocket All Market Tickers Stream
   * @param {AllTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AllTickerResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-tickers-stream Binance API Documentation}
   */
  allTicker(requestParameters = {}) {
    const stream = this.localVarParamCreator.allTicker(requestParameters?.id);
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * Average price streams push changes in the average price over a fixed time interval.
   *
   * @summary WebSocket Average Price
   * @param {AvgPriceRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AvgPriceResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#average-price Binance API Documentation}
   */
  avgPrice(requestParameters) {
    const stream = this.localVarParamCreator.avgPrice(
      requestParameters?.symbol,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
   * Multiple `<symbol>@bookTicker` streams can be subscribed to over one connection.
   *
   * @summary WebSocket Individual Symbol Book Ticker Streams
   * @param {BookTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<BookTickerResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-book-ticker-streams Binance API Documentation}
   */
  bookTicker(requestParameters) {
    const stream = this.localVarParamCreator.bookTicker(
      requestParameters?.symbol,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * Order book price and quantity depth updates used to locally manage an order book.
   *
   * @summary WebSocket Diff. Depth Stream
   * @param {DiffBookDepthRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<DiffBookDepthResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream Binance API Documentation}
   */
  diffBookDepth(requestParameters) {
    const stream = this.localVarParamCreator.diffBookDepth(
      requestParameters?.symbol,
      requestParameters?.id,
      requestParameters?.updateSpeed
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * The Kline/Candlestick Stream push updates to the current klines/candlestick every second in `UTC+0` timezone
   *
   * <a id="kline-intervals"></a>
   *
   * @summary WebSocket Kline/Candlestick Streams for UTC
   * @param {KlineRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<KlineResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-for-utc Binance API Documentation}
   */
  kline(requestParameters) {
    const stream = this.localVarParamCreator.kline(
      requestParameters?.symbol,
      requestParameters?.interval,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * The Kline/Candlestick Stream push updates to the current klines/candlestick every second in `UTC+8` timezone
   *
   * @summary WebSocket Kline/Candlestick Streams with timezone offset
   * @param {KlineOffsetRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<KlineOffsetResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-with-timezone-offset Binance API Documentation}
   */
  klineOffset(requestParameters) {
    const stream = this.localVarParamCreator.klineOffset(
      requestParameters?.symbol,
      requestParameters?.interval,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * 24hr rolling window mini-ticker statistics. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
   *
   * @summary WebSocket Individual Symbol Mini Ticker Stream
   * @param {MiniTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<MiniTickerResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream Binance API Documentation}
   */
  miniTicker(requestParameters) {
    const stream = this.localVarParamCreator.miniTicker(
      requestParameters?.symbol,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * Top **\<levels\>** bids and asks, pushed every second. Valid **\<levels\>** are 5, 10, or 20.
   *
   * @summary WebSocket Partial Book Depth Streams
   * @param {PartialBookDepthRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<PartialBookDepthResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams Binance API Documentation}
   */
  partialBookDepth(requestParameters) {
    const stream = this.localVarParamCreator.partialBookDepth(
      requestParameters?.symbol,
      requestParameters?.levels,
      requestParameters?.id,
      requestParameters?.updateSpeed
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * Rolling window ticker statistics for a single symbol, computed over multiple windows.
   *
   * @summary WebSocket Individual Symbol Rolling Window Statistics Streams
   * @param {RollingWindowTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<RollingWindowTickerResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-rolling-window-statistics-streams Binance API Documentation}
   */
  rollingWindowTicker(requestParameters) {
    const stream = this.localVarParamCreator.rollingWindowTicker(
      requestParameters?.symbol,
      requestParameters?.windowSize,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * 24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
   *
   * @summary WebSocket Individual Symbol Ticker Streams
   * @param {TickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<TickerResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-ticker-streams Binance API Documentation}
   */
  ticker(requestParameters) {
    const stream = this.localVarParamCreator.ticker(
      requestParameters?.symbol,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
  /**
   * The Trade Streams push raw trade information; each trade has a unique buyer and seller.
   *
   * @summary WebSocket Trade Streams
   * @param {TradeRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<TradeResponse>}
   * @throws {RequiredError}
   * @memberof WebSocketStreamsApi
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#trade-streams Binance API Documentation}
   */
  trade(requestParameters) {
    const stream = this.localVarParamCreator.trade(
      requestParameters?.symbol,
      requestParameters?.id
    );
    return (0, import_common8.createStreamHandler)(
      this.websocketBase,
      stream,
      requestParameters?.id
    );
  }
};
var AllMarketRollingWindowTickerWindowSizeEnum = {
  WINDOW_SIZE_1h: "1h",
  WINDOW_SIZE_4h: "4h",
  WINDOW_SIZE_1d: "1d"
};
var KlineIntervalEnum = {
  INTERVAL_1s: "1s",
  INTERVAL_1m: "1m",
  INTERVAL_3m: "3m",
  INTERVAL_5m: "5m",
  INTERVAL_15m: "15m",
  INTERVAL_30m: "30m",
  INTERVAL_1h: "1h",
  INTERVAL_2h: "2h",
  INTERVAL_4h: "4h",
  INTERVAL_6h: "6h",
  INTERVAL_8h: "8h",
  INTERVAL_12h: "12h",
  INTERVAL_1d: "1d",
  INTERVAL_3d: "3d",
  INTERVAL_1w: "1w",
  INTERVAL_1M: "1M"
};
var KlineOffsetIntervalEnum = {
  INTERVAL_1s: "1s",
  INTERVAL_1m: "1m",
  INTERVAL_3m: "3m",
  INTERVAL_5m: "5m",
  INTERVAL_15m: "15m",
  INTERVAL_30m: "30m",
  INTERVAL_1h: "1h",
  INTERVAL_2h: "2h",
  INTERVAL_4h: "4h",
  INTERVAL_6h: "6h",
  INTERVAL_8h: "8h",
  INTERVAL_12h: "12h",
  INTERVAL_1d: "1d",
  INTERVAL_3d: "3d",
  INTERVAL_1w: "1w",
  INTERVAL_1M: "1M"
};
var PartialBookDepthLevelsEnum = {
  LEVELS_5: "5",
  LEVELS_10: "10",
  LEVELS_20: "20"
};
var RollingWindowTickerWindowSizeEnum = {
  WINDOW_SIZE_1h: "1h",
  WINDOW_SIZE_4h: "4h",
  WINDOW_SIZE_1d: "1d"
};

// src/websocket-streams/websocket-streams.ts
var import_common10 = require("@binance/common");

// src/websocket-streams/websocket-streams-connection.ts
var import_common9 = require("@binance/common");
var WebsocketStreamsConnection = class {
  constructor(websocketBase) {
    this.websocketBase = websocketBase;
    this.webSocketStreamsApi = new WebSocketStreamsApi(websocketBase);
  }
  /**
   * Adds an event listener for the specified WebSocket event.
   * @param event - The WebSocket event to listen for, such as 'open', 'message', 'error', 'close', 'ping', or 'pong'.
   * @param listener - The callback function to be executed when the event is triggered. The function can accept any number of arguments.
   */
  on(event, listener) {
    this.websocketBase.on(event, listener);
  }
  /**
   * Removes an event listener for the specified WebSocket event.
   * @param event - The WebSocket event to stop listening for, such as 'open', 'message', 'error', 'close', 'ping', or 'pong'.
   * @param listener - The callback function that was previously added as the event listener.
   */
  off(event, listener) {
    this.websocketBase.off(event, listener);
  }
  /**
   * Disconnects from the WebSocket server.
   * If there is no active connection, a warning is logged.
   * Otherwise, all connections in the connection pool are closed gracefully,
   * and a message is logged indicating that the connection has been disconnected.
   * @returns A Promise that resolves when all connections have been closed.
   * @throws Error if the WebSocket client is not set.
   */
  disconnect() {
    return this.websocketBase.disconnect();
  }
  /**
   * Checks if the WebSocket connection is currently open.
   * @returns `true` if the connection is open, `false` otherwise.
   */
  isConnected() {
    return this.websocketBase.isConnected();
  }
  /**
   * Sends a ping message to all connected Websocket servers in the pool.
   * If no connections are ready, a warning is logged.
   * For each active connection, the ping message is sent, and debug logs provide details.
   * @throws Error if a Websocket client is not set for a connection.
   */
  pingServer() {
    this.websocketBase.pingServer();
  }
  /**
   * Subscribes to one or multiple WebSocket streams
   * Handles both single and pool modes
   * @param stream Single stream name or array of stream names to subscribe to
   * @param id Optional subscription ID
   * @returns void
   */
  subscribe(stream, id) {
    this.websocketBase.subscribe(stream, id);
  }
  /**
   * Unsubscribes from one or multiple WebSocket streams
   * Handles both single and pool modes
   * @param stream Single stream name or array of stream names to unsubscribe from
   * @param id Optional unsubscription ID
   * @returns void
   */
  unsubscribe(stream, id) {
    this.websocketBase.unsubscribe(stream, id);
  }
  /**
   * Checks if the WebSocket connection is subscribed to the specified stream.
   * @param stream The name of the WebSocket stream to check.
   * @returns `true` if the connection is subscribed to the stream, `false` otherwise.
   */
  isSubscribed(stream) {
    return this.websocketBase.isSubscribed(stream);
  }
  /**
   * Subscribes to the user data WebSocket stream using the provided listen key.
   * @param listenKey - The listen key for the user data WebSocket stream.
   * @param id - Optional user data stream ID
   * @returns A WebSocket stream handler for the user data stream.
   */
  userData(listenKey, id) {
    return (0, import_common9.createStreamHandler)(this.websocketBase, listenKey, id);
  }
  /**
   * The Aggregate Trade Streams push trade information that is aggregated for a single taker order.
   *
   * @summary WebSocket Aggregate Trade Streams
   * @param {AggTradeRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AggTradeResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#aggregate-trade-streams Binance API Documentation}
   */
  aggTrade(requestParameters) {
    return this.webSocketStreamsApi.aggTrade(requestParameters);
  }
  /**
   * Rolling window ticker statistics for all market symbols, computed over multiple windows.
   * Note that only tickers that have changed will be present in the array.
   *
   * @summary WebSocket All Market Rolling Window Statistics Streams
   * @param {AllMarketRollingWindowTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AllMarketRollingWindowTickerResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-rolling-window-statistics-streams Binance API Documentation}
   */
  allMarketRollingWindowTicker(requestParameters) {
    return this.webSocketStreamsApi.allMarketRollingWindowTicker(requestParameters);
  }
  /**
   * 24hr rolling window mini-ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.
   *
   * @summary WebSocket All Market Mini Tickers Stream
   * @param {AllMiniTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AllMiniTickerResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream Binance API Documentation}
   */
  allMiniTicker(requestParameters = {}) {
    return this.webSocketStreamsApi.allMiniTicker(requestParameters);
  }
  /**
   * 24hr rolling window ticker statistics for all symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note that only tickers that have changed will be present in the array.
   *
   * @summary WebSocket All Market Tickers Stream
   * @param {AllTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AllTickerResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-tickers-stream Binance API Documentation}
   */
  allTicker(requestParameters = {}) {
    return this.webSocketStreamsApi.allTicker(requestParameters);
  }
  /**
   * Average price streams push changes in the average price over a fixed time interval.
   *
   * @summary WebSocket Average Price
   * @param {AvgPriceRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<AvgPriceResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#average-price Binance API Documentation}
   */
  avgPrice(requestParameters) {
    return this.webSocketStreamsApi.avgPrice(requestParameters);
  }
  /**
   * Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
   * Multiple `<symbol>@bookTicker` streams can be subscribed to over one connection.
   *
   * @summary WebSocket Individual Symbol Book Ticker Streams
   * @param {BookTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<BookTickerResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-book-ticker-streams Binance API Documentation}
   */
  bookTicker(requestParameters) {
    return this.webSocketStreamsApi.bookTicker(requestParameters);
  }
  /**
   * Order book price and quantity depth updates used to locally manage an order book.
   *
   * @summary WebSocket Diff. Depth Stream
   * @param {DiffBookDepthRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<DiffBookDepthResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream Binance API Documentation}
   */
  diffBookDepth(requestParameters) {
    return this.webSocketStreamsApi.diffBookDepth(requestParameters);
  }
  /**
   * The Kline/Candlestick Stream push updates to the current klines/candlestick every second in `UTC+0` timezone
   *
   * <a id="kline-intervals"></a>
   *
   * @summary WebSocket Kline/Candlestick Streams for UTC
   * @param {KlineRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<KlineResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-for-utc Binance API Documentation}
   */
  kline(requestParameters) {
    return this.webSocketStreamsApi.kline(requestParameters);
  }
  /**
   * The Kline/Candlestick Stream push updates to the current klines/candlestick every second in `UTC+8` timezone
   *
   * @summary WebSocket Kline/Candlestick Streams with timezone offset
   * @param {KlineOffsetRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<KlineOffsetResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-with-timezone-offset Binance API Documentation}
   */
  klineOffset(requestParameters) {
    return this.webSocketStreamsApi.klineOffset(requestParameters);
  }
  /**
   * 24hr rolling window mini-ticker statistics. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
   *
   * @summary WebSocket Individual Symbol Mini Ticker Stream
   * @param {MiniTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<MiniTickerResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream Binance API Documentation}
   */
  miniTicker(requestParameters) {
    return this.webSocketStreamsApi.miniTicker(requestParameters);
  }
  /**
   * Top **\<levels\>** bids and asks, pushed every second. Valid **\<levels\>** are 5, 10, or 20.
   *
   * @summary WebSocket Partial Book Depth Streams
   * @param {PartialBookDepthRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<PartialBookDepthResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams Binance API Documentation}
   */
  partialBookDepth(requestParameters) {
    return this.webSocketStreamsApi.partialBookDepth(requestParameters);
  }
  /**
   * Rolling window ticker statistics for a single symbol, computed over multiple windows.
   *
   * @summary WebSocket Individual Symbol Rolling Window Statistics Streams
   * @param {RollingWindowTickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<RollingWindowTickerResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-rolling-window-statistics-streams Binance API Documentation}
   */
  rollingWindowTicker(requestParameters) {
    return this.webSocketStreamsApi.rollingWindowTicker(requestParameters);
  }
  /**
   * 24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
   *
   * @summary WebSocket Individual Symbol Ticker Streams
   * @param {TickerRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<TickerResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-ticker-streams Binance API Documentation}
   */
  ticker(requestParameters) {
    return this.webSocketStreamsApi.ticker(requestParameters);
  }
  /**
   * The Trade Streams push raw trade information; each trade has a unique buyer and seller.
   *
   * @summary WebSocket Trade Streams
   * @param {TradeRequest} requestParameters Request parameters.
   * @returns {WebsocketStream<TradeResponse>}
   * @throws {RequiredError}
   * @see {@link https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#trade-streams Binance API Documentation}
   */
  trade(requestParameters) {
    return this.webSocketStreamsApi.trade(requestParameters);
  }
};

// src/websocket-streams/websocket-streams.ts
var WebsocketStreams = class {
  constructor(configuration) {
    this.configuration = configuration;
  }
  /**
   * Connects to the Binance WebSocket streams and returns a `WebsocketStreamsConnection` instance.
   *
   * @param {object} [options] - Optional connection options.
   * @param {string|string[]} [options.stream] - The stream(s) to connect to.
   * @param {'single'|'pool'} [options.mode] - The connection mode, either 'single' or 'pool'. Overwrite the `mode` option in the configuration.
   * @param {number} [options.poolSize] - The number of connections to use in pool mode. Overwrite the `poolSize` option in the configuration.
   * @returns {Promise<WebsocketStreamsConnection>} - A promise that resolves to a `WebsocketStreamsConnection` instance.
   */
  async connect({
    stream,
    mode,
    poolSize
  } = {}) {
    const websocketBase = new import_common10.WebsocketStreamsBase({
      ...this.configuration,
      ...mode && { mode },
      ...poolSize && { poolSize }
    });
    const websocketStreamsConnection = new WebsocketStreamsConnection(websocketBase);
    await websocketBase.connect(stream);
    return websocketStreamsConnection;
  }
};

// src/spot.ts
var Spot = class {
  constructor(config) {
    if (config?.configurationRestAPI) {
      const configRestAPI = new import_common11.ConfigurationRestAPI(config.configurationRestAPI);
      configRestAPI.basePath = configRestAPI.basePath || import_common11.SPOT_REST_API_PROD_URL;
      configRestAPI.baseOptions = configRestAPI.baseOptions || {};
      configRestAPI.baseOptions.headers = {
        ...configRestAPI.baseOptions.headers || {},
        "User-Agent": `${name}/${version} (Node.js/${process.version}; ${(0, import_os.platform)()}; ${(0, import_os.arch)()})`
      };
      this.restAPI = new RestAPI(configRestAPI);
    }
    if (config?.configurationWebsocketAPI) {
      const configWebsocketAPI = new import_common11.ConfigurationWebsocketAPI(
        config.configurationWebsocketAPI
      );
      configWebsocketAPI.wsURL = configWebsocketAPI.wsURL || import_common11.SPOT_WS_API_PROD_URL;
      this.websocketAPI = new WebsocketAPI(configWebsocketAPI);
    }
    if (config?.configurationWebsocketStreams) {
      const configWebsocketStreams = new import_common11.ConfigurationWebsocketStreams(
        config.configurationWebsocketStreams
      );
      configWebsocketStreams.wsURL = configWebsocketStreams.wsURL || import_common11.SPOT_WS_STREAMS_PROD_URL;
      this.websocketStreams = new WebsocketStreams(configWebsocketStreams);
    }
  }
};

// src/index.ts
var import_common12 = require("@binance/common");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BadRequestError,
  ConnectorClientError,
  ForbiddenError,
  NetworkError,
  NotFoundError,
  RateLimitBanError,
  RequiredError,
  SPOT_REST_API_PROD_URL,
  SPOT_REST_API_TESTNET_URL,
  SPOT_WS_API_PROD_URL,
  SPOT_WS_API_TESTNET_URL,
  SPOT_WS_STREAMS_PROD_URL,
  SPOT_WS_STREAMS_TESTNET_URL,
  ServerError,
  Spot,
  SpotRestAPI,
  SpotWebsocketAPI,
  SpotWebsocketStreams,
  TimeUnit,
  TooManyRequestsError,
  UnauthorizedError
});
//# sourceMappingURL=index.js.map