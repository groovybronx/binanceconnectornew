'use strict'

const axios = require('axios')
const { Console } = require('console')
const constants = require('./constants')
const crypto = require('crypto')

/**
 * @function randomString
 * @description Génère une chaîne de caractères aléatoire de 16 octets en hexadécimal.
 * @returns {string} Une chaîne de caractères aléatoire en hexadécimal.
 */
const randomString = () => crypto.randomBytes(16).toString('hex')

/**
 * @function removeEmptyValue
 * @description Supprime les propriétés avec des valeurs vides d'un objet.
 * @param {object} obj - L'objet à traiter.
 * @returns {object} Un nouvel objet sans les propriétés avec des valeurs vides.
 * @throws {TypeError} Si l'entrée n'est pas un objet.
 */
const removeEmptyValue = obj => {
  if (!(obj instanceof Object)) return {} // Retourne un objet vide si l'entrée n'est pas un objet.
  Object.keys(obj).forEach(key => isEmptyValue(obj[key]) && delete obj[key]) // Supprime les clés avec des valeurs vides.
  return obj
}

/**
 * @function removeTimeUnit
 * @description Supprime la propriété 'timeUnit' d'un objet si elle existe.
 * @param {object} obj - L'objet à traiter.
 * @returns {object} Un nouvel objet sans la propriété 'timeUnit'.
 * @throws {TypeError} Si l'entrée n'est pas un objet.
 */
const removeTimeUnit = obj => {
  if (!(obj instanceof Object)) return {} // Retourne un objet vide si l'entrée n'est pas un objet.
  if ('timeUnit' in obj) delete obj.timeUnit // Supprime la clé 'timeUnit' si elle existe.
  return obj
}

/**
 * @function isEmptyValue
 * @description Vérifie si une valeur est considérée comme vide.
 * @param {*} input - La valeur à vérifier.
 * @returns {boolean} Vrai si la valeur est vide, faux sinon.
 * @description Une valeur est considérée comme vide si elle est :
 * - Fausse (sauf pour false et 0)
 * - Une chaîne de caractères contenant uniquement des espaces blancs
 * - Un objet vide
 * - Un tableau vide
 */
const isEmptyValue = input => {
  /**
   * Portée d'une valeur vide : valeur fausse (sauf pour false et 0),
   * chaîne de caractères avec uniquement des caractères d'espacement, objet vide, tableau vide
   */
  return (!input && input !== false && input !== 0) ||
    ((typeof input === 'string' || input instanceof String) && /^\s+$/.test(input)) ||
    (input instanceof Object && !Object.keys(input).length) ||
    (Array.isArray(input) && !input.length)
}

/**
 * @function buildQueryString
 * @description Construit une chaîne de requête à partir d'un objet de paramètres.
 * @param {object} params - L'objet contenant les paramètres.
 * @returns {string} La chaîne de requête construite.
 */
const buildQueryString = params => {
  if (!params) return '' // Retourne une chaîne vide si aucun paramètre n'est fourni.
  return Object.entries(params)
    .map(stringifyKeyValuePair) // Convertit chaque paire clé-valeur en une chaîne.
    .join('&') // Joint les paires avec le caractère '&'.
}

/**
 * @function stringifyKeyValuePair
 * @description Convertit une paire clé-valeur en une chaîne de caractères pour la requête.
 * @param {Array} param - Une paire clé-valeur sous forme de tableau [clé, valeur].
 * @returns {string} La chaîne de caractères représentant la paire clé-valeur.
 * @description La logique de conversion de tableau est différente de la chaîne de requête habituelle.
 * Par exemple, symbols=["BTCUSDT","BNBBTC"] au lieu de symbols[]=BTCUSDT&symbols[]=BNBBTC
 */
const stringifyKeyValuePair = ([key, value]) => {
  const valueString = Array.isArray(value) ? `["${value.join('","')}"]` : value // Gère les tableaux différemment.
  return `${key}=${encodeURIComponent(valueString)}` // Encode la valeur pour l'URL.
}

/**
 * @function getRequestInstance
 * @description Crée et retourne une instance d'axios configurée.
 * @param {object} config - La configuration pour l'instance d'axios.
 * @returns {object} Une instance d'axios configurée.
 */
const getRequestInstance = (config) => {
  return axios.create({
    ...config
  })
}

/**
 * @function createRequest
 * @description Crée et envoie une requête HTTP.
 * @param {object} config - La configuration de la requête.
 * @param {string} config.baseURL - L'URL de base.
 * @param {string} config.apiKey - La clé API.
 * @param {string} config.method - La méthode HTTP (GET, POST, etc.).
 * @param {string} config.url - L'URL de la requête.
 * @param {number} config.timeout - Le délai d'attente en millisecondes.
 * @param {object} config.proxy - La configuration du proxy.
 * @param {object} config.httpsAgent - L'agent HTTPS.
 * @param {string} [config.timeUnit] - L'unité de temps.
 * @returns {Promise} Une promesse qui se résout avec la réponse de la requête.
 */
const createRequest = (config) => {
  const { baseURL, apiKey, method, url, timeout, proxy, httpsAgent, timeUnit } = config
  const requestInstance = {
    baseURL,
    timeout,
    proxy,
    httpsAgent,
    headers: {
      'Content-Type': 'application/json',
      'X-MBX-APIKEY': apiKey,
      'User-Agent': `${constants.appName}/${constants.appVersion}`
    }
  }
  if (timeUnit) {
    requestInstance.headers['X-MBX-TIME-UNIT'] = timeUnit
  }
  return getRequestInstance(requestInstance)
    .request({
      method,
      url
    })
}

/**
 * @function flowRight
 * @description Compose des fonctions de droite à gauche.
 * @param {...function} functions - Les fonctions à composer.
 * @returns {function} Une fonction composée.
 */
const flowRight = (...functions) => input => functions.reduceRight(
  (input, fn) => fn(input),
  input
)

/**
 * @constant defaultLogger
 * @description Un logger par défaut qui utilise la console.
 */
const defaultLogger = new Console({
  stdout: process.stdout,
  stderr: process.stderr
})

/**
 * @function sortObject
 * @description Trie les clés d'un objet par ordre alphabétique.
 * @param {object} obj - L'objet à trier.
 * @returns {object} Un nouvel objet avec les clés triées.
 */
const sortObject = obj => Object.keys(obj).sort().reduce((res, key) => {
  res[key] = obj[key]
  return res
}, {})

module.exports = {
  isEmptyValue,
  removeEmptyValue,
  removeTimeUnit,
  buildQueryString,
  createRequest,
  flowRight,
  defaultLogger,
  randomString,
  sortObject
}
